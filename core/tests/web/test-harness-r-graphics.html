<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R Graphics Functions Test Harness</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .chart-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            color: #333;
        }
        canvas {
            border: 1px solid #ddd;
            display: block;
            margin: 0 auto;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        button.chart-btn {
            background: #28a745;
        }
        button.chart-btn:hover {
            background: #218838;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        .log-success { color: #28a745; }
        .log-error { color: #dc3545; }
        .log-info { color: #6c757d; }
        .log-warning { color: #ffc107; }
        textarea {
            width: 100%;
            height: 100px;
            margin-bottom: 10px;
            font-family: monospace;
            font-size: 12px;
        }
        .stats-panel {
            background: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }
        .implemented { color: #28a745; font-weight: bold; }
        .placeholder { color: #ffc107; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>R Graphics Functions Test Harness</h1>
        
        <div class="controls">
            <h3>Chart Generation</h3>
            <button class="chart-btn" onclick="generateChart('histogram')">üìä Generate Histogram</button>
            <button class="chart-btn" onclick="generateChart('boxplot')">üì¶ Generate Boxplot</button>
            <button class="chart-btn" onclick="generateChart('scatter')">üîµ Generate Scatter Plot</button>
            <button class="chart-btn" onclick="generateChart('barplot')">üìä Generate Barplot</button>
            <button class="chart-btn" onclick="generateChart('pie')">ü•ß Generate Pie Chart</button>
            <button class="chart-btn" onclick="generateChart('qqplot')">üìà Generate Q-Q Plot</button>
            <button class="chart-btn" onclick="generateChart('density')">„Ä∞Ô∏è Generate Density Plot</button>
            
            <br><br>
            
            <button onclick="generateAllCharts()">üé® Generate All Charts</button>
            <button onclick="clearLog()">üóëÔ∏è Clear Log</button>
            <button onclick="downloadCanvasAsPNG('histogram-canvas')">üíæ Download Histogram PNG</button>
            <button onclick="showStatsSummary()">üìà Show Statistics Summary</button>
            
            <h4>Custom R Graphics Code Execution</h4>
            <textarea id="customCode" placeholder="Enter R Graphics JavaScript code here...">
// Example: Generate custom scatter plot with correlation
const x = Array.from({length: 30}, (_, i) => i + Math.random() * 3);
const y = x.map(val => val * 1.5 + Math.random() * 8 + 5); // Linear relationship with noise

const scatterData = generateScatterPlot(x, y, {
  main: 'Custom Correlation Plot',
  xlab: 'X Variable', 
  ylab: 'Y Variable (1.5x + noise)',
  col: 'darkgreen'
});
renderPlotToCanvas(scatterData, 'custom-canvas');
log('‚úÖ Custom scatter plot generated!', 'success');</textarea>
            <button onclick="executeCustomCode()">‚ñ∂Ô∏è Execute Custom Code</button>
            
            <div id="log" class="log"></div>
        </div>

        <div class="chart-grid">
            <div class="chart-card">
                <div class="chart-title">üìä Histogram - Normal Distribution</div>
                <canvas id="histogram-canvas" width="400" height="300"></canvas>
                <div class="stats-panel" id="histogram-stats"></div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">üì¶ Boxplot - Outlier Detection</div>
                <canvas id="boxplot-canvas" width="400" height="300"></canvas>
                <div class="stats-panel" id="boxplot-stats"></div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">üîµ Scatter Plot - Correlation Analysis</div>
                <canvas id="scatter-canvas" width="400" height="300"></canvas>
                <div class="stats-panel" id="scatter-stats"></div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">üìä Barplot - Categorical Data</div>
                <canvas id="barplot-canvas" width="400" height="300"></canvas>
                <div class="stats-panel" id="barplot-stats"></div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">ü•ß Pie Chart - Proportional Data</div>
                <canvas id="pie-canvas" width="400" height="300"></canvas>
                <div class="stats-panel" id="pie-stats"></div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">üìà Q-Q Plot - Distribution Comparison</div>
                <canvas id="qqplot-canvas" width="400" height="300"></canvas>
                <div class="stats-panel" id="qqplot-stats"></div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">„Ä∞Ô∏è Density Plot - Distribution Shape</div>
                <canvas id="density-canvas" width="400" height="300"></canvas>
                <div class="stats-panel" id="density-stats"></div>
            </div>

            <!-- Custom chart area -->
            <div class="chart-card">
                <div class="chart-title">‚öôÔ∏è Custom Chart</div>
                <canvas id="custom-canvas" width="400" height="300"></canvas>
                <div class="stats-panel" id="custom-stats"></div>
            </div>
        </div>
    </div>

    <script src="../histogram-browser-renderer.js"></script>
    <script>
        // Test harness functionality
        let logCount = 0;
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${++logCount}] ${new Date().toLocaleTimeString()} - ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            logCount = 0;
            log('Log cleared', 'info');
        }

        // R Graphics function wrappers that match the Node.js API
        function generateScatterPlot(x, y, options = {}) {
            try {
                const xData = Array.isArray(x) ? x : [x];
                const yData = Array.isArray(y) ? y : [y];
                
                if (xData.length !== yData.length) {
                    return { type: 'scatter', error: 'X and Y arrays must have same length' };
                }
                
                return {
                    type: 'scatter',
                    x: xData,
                    y: yData,
                    options: {
                        main: options.main || 'Scatter Plot',
                        xlab: options.xlab || 'X',
                        ylab: options.ylab || 'Y',
                        col: options.col || 'blue',
                        pch: options.pch || 1
                    },
                    timestamp: new Date().toISOString()
                };
            } catch (e) {
                return { type: 'scatter', error: e.message };
            }
        }

        function generateBoxplot(data, options = {}) {
            try {
                const numericData = data.filter(val => !isNaN(parseFloat(val))).map(val => parseFloat(val));
                
                if (numericData.length === 0) {
                    return { type: 'boxplot', error: 'No numeric data provided' };
                }

                const sorted = numericData.sort((a, b) => a - b);
                const n = sorted.length;
                
                // Calculate quartiles (simple method)
                const q1 = sorted[Math.floor(n * 0.25)];
                const q2 = sorted[Math.floor(n * 0.5)];
                const q3 = sorted[Math.floor(n * 0.75)];
                const iqr = q3 - q1;
                
                // Calculate whiskers
                const lowerWhisker = Math.max(sorted[0], q1 - 1.5 * iqr);
                const upperWhisker = Math.min(sorted[n - 1], q3 + 1.5 * iqr);
                
                // Find outliers
                const outliers = sorted.filter(val => val < lowerWhisker || val > upperWhisker);

                return {
                    type: 'boxplot',
                    data: numericData,
                    stats: {
                        min: sorted[0],
                        q1: q1,
                        median: q2,
                        q3: q3,
                        max: sorted[n - 1],
                        iqr: iqr,
                        lowerWhisker: lowerWhisker,
                        upperWhisker: upperWhisker,
                        outliers: outliers,
                        n: n
                    },
                    options: {
                        main: options.main || 'Box Plot',
                        xlab: options.xlab || '',
                        ylab: options.ylab || 'Value',
                        col: options.col || 'lightblue',
                        border: options.border || 'black'
                    },
                    timestamp: new Date().toISOString()
                };
            } catch (e) {
                return { type: 'boxplot', error: e.message };
            }
        }

        // Browser-compatible R Graphics generation functions
        function generateBarplot(heights, options = {}) {
            try {
                const data = Array.isArray(heights) ? heights : [heights];
                const numericData = data.map(val => parseFloat(val) || 0);
                
                return {
                    type: 'barplot',
                    heights: numericData,
                    names: options.names || numericData.map((_, i) => (i + 1).toString()),
                    options: {
                        main: options.main || 'Bar Plot',
                        xlab: options.xlab || '',
                        ylab: options.ylab || 'Height',
                        col: options.col || 'gray',
                        border: options.border || 'black',
                        labels: options.labels !== false
                    },
                    timestamp: new Date().toISOString()
                };
            } catch (e) {
                return { type: 'barplot', error: e.message };
            }
        }

        function generatePieChart(values, options = {}) {
            try {
                const data = Array.isArray(values) ? values : [values];
                const numericData = data.map(val => parseFloat(val) || 0);
                
                // Check for non-positive values
                if (numericData.some(val => val <= 0)) {
                    return { type: 'pie', error: 'Pie chart values must be positive' };
                }
                
                const total = numericData.reduce((sum, val) => sum + val, 0);
                if (total === 0) {
                    return { type: 'pie', error: 'Sum of pie chart values cannot be zero' };
                }
                
                const percentages = numericData.map(val => (val / total) * 100);
                const angles = percentages.map(pct => (pct / 100) * 360);
                const labels = options.labels || numericData.map((_, i) => (i + 1).toString());
                
                return {
                    type: 'pie',
                    values: numericData,
                    percentages: percentages,
                    angles: angles,
                    labels: labels,
                    options: {
                        main: options.main || 'Pie Chart',
                        col: options.col,
                        border: options.border || 'white'
                    },
                    timestamp: new Date().toISOString()
                };
            } catch (e) {
                return { type: 'pie', error: e.message };
            }
        }

        function generateDensityPlot(data, options = {}) {
            try {
                const numericData = Array.isArray(data) ? data.filter(val => !isNaN(parseFloat(val))).map(parseFloat) : [parseFloat(data)];
                
                if (numericData.length < 2) {
                    return { type: 'density', error: 'Need at least 2 data points' };
                }

                // Simple kernel density estimation (Gaussian kernel)
                const sortedData = numericData.slice().sort((a, b) => a - b);
                const min = sortedData[0];
                const max = sortedData[sortedData.length - 1];
                const range = max - min;
                const bandwidth = range / (numericData.length * 0.2); // Simple bandwidth selection
                
                const nPoints = 100;
                const x = [];
                const y = [];
                
                for (let i = 0; i < nPoints; i++) {
                    const xi = min - range * 0.2 + (i / (nPoints - 1)) * (range * 1.4);
                    x.push(xi);
                    
                    let density = 0;
                    for (let j = 0; j < numericData.length; j++) {
                        const u = (xi - numericData[j]) / bandwidth;
                        density += Math.exp(-0.5 * u * u);
                    }
                    density /= (numericData.length * bandwidth * Math.sqrt(2 * Math.PI));
                    y.push(density);
                }

                return {
                    type: 'density',
                    x: x,
                    y: y,
                    data: numericData,
                    options: {
                        main: options.main || 'Density Plot',
                        xlab: options.xlab || '',
                        ylab: options.ylab || 'Density',
                        col: options.col || 'blue',
                        lwd: options.lwd || 2,
                        fill: options.fill !== false,
                        fillCol: options.fillCol || 'rgba(0, 0, 255, 0.2)'
                    },
                    timestamp: new Date().toISOString()
                };
            } catch (e) {
                return { type: 'density', error: e.message };
            }
        }

        function generateQQPlot(data, theoretical = null, options = {}) {
            try {
                const numericData = Array.isArray(data) ? data.filter(val => !isNaN(parseFloat(val))).map(parseFloat) : [parseFloat(data)];
                
                if (numericData.length < 2) {
                    return { type: 'qqplot', error: 'Need at least 2 data points' };
                }

                // Sort sample data
                const sortedData = numericData.slice().sort((a, b) => a - b);
                const n = sortedData.length;
                
                // Generate theoretical quantiles (standard normal if not provided)
                const theoreticalQuantiles = [];
                if (theoretical === null) {
                    // Generate standard normal quantiles
                    for (let i = 0; i < n; i++) {
                        const p = (i + 0.5) / n; // Probability
                        // Approximate inverse normal using Box-Muller transformation
                        const z = Math.sqrt(-2 * Math.log(1 - p)) * Math.cos(2 * Math.PI * Math.random());
                        theoreticalQuantiles.push(z);
                    }
                    theoreticalQuantiles.sort((a, b) => a - b);
                } else {
                    const theoreticalData = Array.isArray(theoretical) ? theoretical.filter(val => !isNaN(parseFloat(val))).map(parseFloat) : [parseFloat(theoretical)];
                    theoreticalQuantiles.push(...theoreticalData.slice().sort((a, b) => a - b));
                }

                return {
                    type: 'qqplot',
                    x: theoreticalQuantiles.slice(0, n),
                    y: sortedData,
                    options: {
                        main: options.main || 'Q-Q Plot',
                        xlab: options.xlab || 'Theoretical Quantiles',
                        ylab: options.ylab || 'Sample Quantiles',
                        col: options.col || 'blue',
                        cex: options.cex || 1
                    },
                    timestamp: new Date().toISOString()
                };
            } catch (e) {
                return { type: 'qqplot', error: e.message };
            }
        }

        function generateChart(chartType) {
            log(`Generating ${chartType}...`, 'info');
            
            try {
                let chartData, canvasId, statsId;
                
                switch (chartType) {
                    case 'histogram':
                        // Generate normal distribution data
                        const histData = [];
                        for (let i = 0; i < 1000; i++) {
                            const u1 = Math.random();
                            const u2 = Math.random();
                            const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                            histData.push(z0 * 20 + 50);
                        }
                        chartData = generateHistogram(histData, {
                            main: 'Normal Distribution (Œº=50, œÉ=20)',
                            xlab: 'Value',
                            ylab: 'Frequency',
                            col: 'skyblue',
                            breaks: 25
                        });
                        canvasId = 'histogram-canvas';
                        statsId = 'histogram-stats';
                        break;
                        
                    case 'boxplot':
                        // Generate data with outliers
                        const boxData = [
                            ...Array.from({length: 80}, () => Math.random() * 20 + 40), // Main data
                            15, 85, 90, 95 // Outliers
                        ];
                        chartData = generateBoxplot(boxData, {
                            main: 'Data Distribution with Outliers',
                            ylab: 'Values',
                            col: 'lightgreen'
                        });
                        canvasId = 'boxplot-canvas';
                        statsId = 'boxplot-stats';
                        break;
                        
                    case 'scatter':
                        // Generate correlated data
                        const scatterX = Array.from({length: 50}, (_, i) => i * 2 + Math.random() * 5);
                        const scatterY = scatterX.map(x => x * 1.2 + Math.random() * 15 + 10);
                        chartData = generateScatterPlot(scatterX, scatterY, {
                            main: 'Correlation Analysis (r ‚âà 0.8)',
                            xlab: 'Independent Variable',
                            ylab: 'Dependent Variable',
                            col: 'darkblue'
                        });
                        canvasId = 'scatter-canvas';
                        statsId = 'scatter-stats';
                        break;
                        
                    case 'barplot':
                        // Generate categorical data
                        const barHeights = [25, 18, 32, 14, 28, 21];
                        const barNames = ['Product A', 'Product B', 'Product C', 'Product D', 'Product E', 'Product F'];
                        chartData = generateBarplot(barHeights, {
                            names: barNames,
                            main: 'Sales by Product Category',
                            xlab: 'Products',
                            ylab: 'Sales (K$)',
                            col: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD']
                        });
                        canvasId = 'barplot-canvas';
                        statsId = 'barplot-stats';
                        break;
                        
                    case 'pie':
                        // Generate market share data
                        const pieValues = [35, 25, 20, 15, 5];
                        const pieLabels = ['Chrome', 'Safari', 'Firefox', 'Edge', 'Other'];
                        chartData = generatePieChart(pieValues, {
                            labels: pieLabels,
                            main: 'Browser Market Share 2024',
                            col: ['#4285F4', '#FF9500', '#FF6611', '#0078D4', '#999999']
                        });
                        canvasId = 'pie-canvas';
                        statsId = 'pie-stats';
                        break;
                        
                    case 'qqplot':
                        // Generate sample data for Q-Q plot
                        const qqSampleData = Array.from({length: 50}, () => {
                            // Generate data with slight skew
                            return Math.pow(Math.random(), 1.2) * 20 + 5;
                        });
                        chartData = generateQQPlot(qqSampleData, null, {
                            main: 'Q-Q Plot vs Normal Distribution',
                            col: 'darkgreen'
                        });
                        canvasId = 'qqplot-canvas';
                        statsId = 'qqplot-stats';
                        break;
                        
                    case 'density':
                        // Generate data with mixed distribution
                        const densityData = [
                            ...Array.from({length: 100}, () => Math.random() * 8 + 2), // Uniform component
                            ...Array.from({length: 50}, () => { // Normal component
                                const u1 = Math.random();
                                const u2 = Math.random();
                                return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2) * 3 + 15;
                            })
                        ];
                        chartData = generateDensityPlot(densityData, {
                            main: 'Mixed Distribution Density',
                            xlab: 'Value',
                            col: 'purple',
                            fillCol: 'rgba(128, 0, 128, 0.3)'
                        });
                        canvasId = 'density-canvas';
                        statsId = 'density-stats';
                        break;
                        
                    default:
                        throw new Error(`Unknown chart type: ${chartType}`);
                }
                
                if (chartData.error) {
                    log(`‚ùå Error generating ${chartType}: ${chartData.error}`, 'error');
                    return;
                }
                
                // Render the chart
                renderPlotToCanvas(chartData, canvasId);
                
                // Update statistics panel
                updateStatsPanel(chartData, statsId);
                
                log(`‚úÖ ${chartType} generated successfully`, 'success');
                
            } catch (error) {
                log(`‚ùå Error generating ${chartType}: ${error.message}`, 'error');
            }
        }

        function updateStatsPanel(chartData, statsId) {
            const panel = document.getElementById(statsId);
            if (!panel) return;
            
            let statsHtml = '';
            
            if (chartData.placeholder) {
                statsHtml = `<span class="placeholder">‚ö†Ô∏è Rendering not yet implemented</span>`;
            } else if (chartData.error) {
                statsHtml = `<span class="log-error">‚ùå Error: ${chartData.error}</span>`;
            } else {
                statsHtml = `<span class="implemented">‚úÖ Fully Implemented</span><br>`;
                
                switch (chartData.type) {
                    case 'hist':
                        statsHtml += `
                            Data Points: ${chartData.data.length}<br>
                            Bins: ${chartData.bins.length}<br>
                            Range: ${Math.min(...chartData.data).toFixed(2)} to ${Math.max(...chartData.data).toFixed(2)}<br>
                            Total Frequency: ${chartData.counts.reduce((a, b) => a + b, 0)}
                        `;
                        break;
                    case 'boxplot':
                        statsHtml += `
                            N: ${chartData.stats.n}<br>
                            Median: ${chartData.stats.median.toFixed(2)}<br>
                            Q1: ${chartData.stats.q1.toFixed(2)}, Q3: ${chartData.stats.q3.toFixed(2)}<br>
                            IQR: ${chartData.stats.iqr.toFixed(2)}<br>
                            Outliers: ${chartData.stats.outliers.length}
                        `;
                        break;
                    case 'scatter':
                        const correlation = calculateCorrelation(chartData.x, chartData.y);
                        statsHtml += `
                            Points: ${chartData.x.length}<br>
                            X Range: ${Math.min(...chartData.x).toFixed(2)} to ${Math.max(...chartData.x).toFixed(2)}<br>
                            Y Range: ${Math.min(...chartData.y).toFixed(2)} to ${Math.max(...chartData.y).toFixed(2)}<br>
                            Correlation: ${correlation.toFixed(3)}
                        `;
                        break;
                    case 'barplot':
                        const maxBarHeight = Math.max(...chartData.heights);
                        const totalBarHeight = chartData.heights.reduce((a, b) => a + b, 0);
                        statsHtml += `
                            Categories: ${chartData.heights.length}<br>
                            Max Value: ${maxBarHeight.toFixed(1)}<br>
                            Total: ${totalBarHeight.toFixed(1)}<br>
                            Average: ${(totalBarHeight / chartData.heights.length).toFixed(1)}
                        `;
                        break;
                    case 'pie':
                        const totalPieValue = chartData.values.reduce((a, b) => a + b, 0);
                        const maxSlice = Math.max(...chartData.percentages);
                        statsHtml += `
                            Slices: ${chartData.values.length}<br>
                            Total Value: ${totalPieValue.toFixed(1)}<br>
                            Largest Slice: ${maxSlice.toFixed(1)}%<br>
                            Total Percentage: 100%
                        `;
                        break;
                    case 'density':
                        const maxDensity = Math.max(...chartData.y);
                        const dataRange = Math.max(...chartData.data) - Math.min(...chartData.data);
                        statsHtml += `
                            Data Points: ${chartData.data.length}<br>
                            X Range: ${Math.min(...chartData.x).toFixed(2)} to ${Math.max(...chartData.x).toFixed(2)}<br>
                            Max Density: ${maxDensity.toFixed(4)}<br>
                            Data Range: ${dataRange.toFixed(2)}
                        `;
                        break;
                    case 'qqplot':
                        const qqCorrelation = calculateCorrelation(chartData.x, chartData.y);
                        const deviationSum = chartData.x.reduce((sum, x, i) => {
                            const y = chartData.y[i];
                            return sum + Math.abs(y - x);
                        }, 0);
                        const avgDeviation = deviationSum / chartData.x.length;
                        statsHtml += `
                            Points: ${chartData.x.length}<br>
                            Correlation: ${qqCorrelation.toFixed(3)}<br>
                            Avg Deviation: ${avgDeviation.toFixed(3)}<br>
                            Normality: ${qqCorrelation > 0.95 ? 'Good' : qqCorrelation > 0.85 ? 'Moderate' : 'Poor'}
                        `;
                        break;
                }
            }
            
            panel.innerHTML = statsHtml;
        }

        function calculateCorrelation(x, y) {
            const n = x.length;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }

        function generateAllCharts() {
            log('Generating all available charts...', 'info');
            
            const chartTypes = ['histogram', 'boxplot', 'scatter', 'barplot', 'pie', 'qqplot', 'density'];
            let completed = 0;
            
            chartTypes.forEach((type, index) => {
                setTimeout(() => {
                    generateChart(type);
                    completed++;
                    if (completed === chartTypes.length) {
                        log('üéØ All charts generation complete!', 'success');
                    }
                }, index * 500); // Stagger generation to avoid overwhelming the UI
            });
        }

        function executeCustomCode() {
            const code = document.getElementById('customCode').value;
            try {
                log('Executing custom R Graphics code...', 'info');
                eval(code);
                log('‚úÖ Custom code executed successfully', 'success');
            } catch (error) {
                log(`‚ùå Custom code error: ${error.message}`, 'error');
            }
        }

        function downloadCanvasAsPNG(canvasId) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = `${canvasId}-chart.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            log(`üì• Downloaded ${canvasId}-chart.png`, 'success');
        }

        function showStatsSummary() {
            const implementedCount = 7; // histogram, boxplot, scatter, barplot, pie, density, qqplot
            const totalCount = 7; // all R Graphics functions shown
            const percentage = Math.round((implementedCount / totalCount) * 100);
            
            log(`üìä Implementation Status: ${implementedCount}/${totalCount} (${percentage}%) charts fully implemented`, 'info');
            log(`‚úÖ Implemented: Histogram, Boxplot, Scatter Plot, Barplot, Pie Chart, Density Plot, Q-Q Plot`, 'success');
            log(`üéâ All R Graphics Functions are now fully implemented!`, 'success');
        }

        // Auto-generate charts on load
        window.addEventListener('load', () => {
            log('R Graphics test harness loaded', 'info');
            log('Click individual chart buttons or "Generate All Charts" to see visualizations', 'info');
            
            // Generate default examples
            setTimeout(() => {
                generateChart('histogram');
                setTimeout(() => generateChart('boxplot'), 1000);
                setTimeout(() => generateChart('scatter'), 2000);
            }, 500);
        });
    </script>
</body>
</html>