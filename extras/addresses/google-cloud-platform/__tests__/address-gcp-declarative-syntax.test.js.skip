/* Copyright (c) 2025 Paul Hammant ... Licensed under the MIT License */

/**
 * Tests for GCP ADDRESS Handler - Declarative Syntax & Variable Interpolation
 *
 * Pattern: Jest -> JavaScript -> Embedded RexxJS -> Jest Assertions
 * Tests the new DSL features: WITH...END blocks and {{var}} interpolation
 */

const { Interpreter } = require('../../../../core/src/interpreter');
const { parse } = require('../../../../core/src/parser');
const path = require('path');

// Mock googleapis before any imports
jest.mock('googleapis', () => ({
  google: {
    auth: { GoogleAuth: jest.fn() },
    sheets: jest.fn(() => ({ spreadsheets: { get: jest.fn(), values: { get: jest.fn(), append: jest.fn() } } }))
  }
}));

// Mock child_process for gcloud commands
jest.mock('child_process', () => ({
  spawn: jest.fn(),
  exec: jest.fn((cmd, callback) => {
    // Mock gcloud config get-value project
    if (cmd.includes('gcloud config get-value project')) {
      callback(null, 'test-project-123', '');
    } else {
      callback(null, 'mock output', '');
    }
  })
}));

describe('GCP ADDRESS Handler - Declarative Syntax', () => {
  let interpreter;

  beforeEach(() => {
    // Mock RPC client
    const mockRpcClient = {
      send: jest.fn().mockResolvedValue('mock response')
    };
    interpreter = new Interpreter(mockRpcClient);

    // Clear any existing GCP handler state
    if (global.gcpHandlerInstance) {
      global.gcpHandlerInstance = null;
    }
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Declarative Parser - Basic Functionality', () => {
    test('should parse simple key-value pairs', async () => {
      const { DeclarativeParser } = require('../../shared-utils/declarative-parser');

      const input = `
        protocol HTTP
        timeout 30s
        port 8080
      `;

      const parser = new DeclarativeParser();
      const result = parser.parse(input);

      expect(result.protocol).toBe('HTTP');
      expect(result.timeout).toBe('30s');
      expect(result.port).toBe(8080);
    });

    test('should parse nested blocks', async () => {
      const { DeclarativeParser } = require('../../shared-utils/declarative-parser');

      const input = `
        backend_service "web-backend" {
          protocol HTTP
          timeout 30s
        }
      `;

      const parser = new DeclarativeParser();
      const result = parser.parse(input);

      expect(result.backend_service).toBeDefined();
      expect(result.backend_service.name).toBe('web-backend');
      expect(result.backend_service.protocol).toBe('HTTP');
      expect(result.backend_service.timeout).toBe('30s');
    });

    test('should parse deeply nested blocks', async () => {
      const { DeclarativeParser } = require('../../shared-utils/declarative-parser');

      const input = `
        backend_service "web-backend" {
          protocol HTTP
          health_check {
            port 80
            request_path /health
          }
        }
      `;

      const parser = new DeclarativeParser();
      const result = parser.parse(input);

      expect(result.backend_service.health_check).toBeDefined();
      expect(result.backend_service.health_check.port).toBe(80);
      expect(result.backend_service.health_check.request_path).toBe('/health');
    });

    test('should parse arrays', async () => {
      const { DeclarativeParser } = require('../../shared-utils/declarative-parser');

      const input = `
        domains ["example.com", "www.example.com"]
        ports [80, 443]
      `;

      const parser = new DeclarativeParser();
      const result = parser.parse(input);

      expect(result.domains).toEqual(['example.com', 'www.example.com']);
      expect(result.ports).toEqual([80, 443]);
    });

    test('should handle comments', async () => {
      const { DeclarativeParser } = require('../../shared-utils/declarative-parser');

      const input = `
        protocol HTTP  # This is a comment
        # Full line comment
        port 8080
      `;

      const parser = new DeclarativeParser();
      const result = parser.parse(input);

      expect(result.protocol).toBe('HTTP');
      expect(result.port).toBe(8080);
    });
  });

  describe('Variable Interpolation - Parser Level', () => {
    test('should interpolate variables with handlebars pattern', async () => {
      const { DeclarativeParser } = require('../../shared-utils/declarative-parser');

      const variableStore = {
        env: 'production',
        port: 443
      };

      const input = `
        name {{env}}-server
        port {{port}}
      `;

      const parser = new DeclarativeParser(variableStore);
      const result = parser.parse(input);

      expect(result.name).toBe('production-server');
      expect(result.port).toBe(443);
    });

    test('should leave unknown variables as-is', async () => {
      const { DeclarativeParser } = require('../../shared-utils/declarative-parser');

      const variableStore = {
        env: 'production'
      };

      const input = `
        name {{env}}-{{unknown}}-server
      `;

      const parser = new DeclarativeParser(variableStore);
      const result = parser.parse(input);

      expect(result.name).toBe('production-{{unknown}}-server');
    });

    test('should interpolate in nested blocks', async () => {
      const { DeclarativeParser } = require('../../shared-utils/declarative-parser');

      const variableStore = {
        env: 'staging',
        health_port: 8080,
        health_path: '/healthz'
      };

      const input = `
        backend_service "{{env}}-backend" {
          health_check {
            port {{health_port}}
            request_path "{{health_path}}"
          }
        }
      `;

      const parser = new DeclarativeParser(variableStore);
      const result = parser.parse(input);

      expect(result.backend_service.name).toBe('staging-backend');
      expect(result.backend_service.health_check.port).toBe(8080);
      expect(result.backend_service.health_check.request_path).toBe('/healthz');
    });
  });

  describe('Declarative Syntax - Load Balancer via RexxJS', () => {
    test('should create load balancer with declarative syntax', async () => {
      // Load GCP address handler

      const script = `
        ADDRESS GCP 'LOAD-BALANCER test-lb WITH
        backend_service "test-backend" {
          protocol HTTP
          timeout 30s
        }
        frontend {
          port 80
        }
        END'
      `;

      // Mock gcloud commands
      const { spawn } = require('child_process');
      spawn.mockReturnValue({
        stdout: { on: jest.fn() },
        stderr: { on: jest.fn() },
        on: jest.fn((event, callback) => {
          if (event === 'close') callback(0);
        })
      });

      await interpreter.run(parse(script));

      const rc = interpreter.getVariable('RC');
      expect(rc).toBe(0);
    });

    test('should handle complex load balancer with multiple backends', async () => {

      const script = `
        ADDRESS GCP 'LOAD-BALANCER multi-backend-lb WITH
        backend_service "primary-backend" {
          protocol HTTPS
          timeout 60s
          health_check {
            port 443
            request_path /health
            check_interval 10s
          }
        }
        url_map "main-map" {
          default_service primary-backend
        }
        frontend {
          port 443
          protocol HTTPS
        }
        END'
      `;

      const { spawn } = require('child_process');
      spawn.mockReturnValue({
        stdout: { on: jest.fn() },
        stderr: { on: jest.fn() },
        on: jest.fn((event, callback) => {
          if (event === 'close') callback(0);
        })
      });

      await interpreter.run(parse(script));

      const rc = interpreter.getVariable('RC');
      expect(rc).toBe(0);
    });
  });

  describe('Variable Interpolation - Full Stack (RexxJS â†’ GCP Handler)', () => {
    test('should interpolate REXX variables in declarative block', async () => {

      const script = `
        /* Set interpolation pattern */
        CALL setInterpolationPattern 'handlebars'

        /* Define REXX variables */
        env = "production"
        port = 443
        timeout = "60s"

        /* Use in declarative block */
        ADDRESS GCP 'LOAD-BALANCER {{env}}-lb WITH
        backend_service "{{env}}-backend" {
          protocol HTTPS
          timeout {{timeout}}
          health_check {
            port {{port}}
          }
        }
        END'
      `;

      const { spawn } = require('child_process');
      let capturedCommand = '';
      spawn.mockImplementation((cmd, args) => {
        capturedCommand = args.join(' ');
        return {
          stdout: { on: jest.fn() },
          stderr: { on: jest.fn() },
          on: jest.fn((event, callback) => {
            if (event === 'close') callback(0);
          })
        };
      });

      await interpreter.run(parse(script));

      const rc = interpreter.getVariable('RC');
      expect(rc).toBe(0);

      // Verify interpolation happened (command should contain "production", not "{{env}}")
      // Note: This is a basic check - actual verification would depend on implementation
    });

    test('should support shell-style interpolation pattern', async () => {

      const script = `
        /* Set shell-style interpolation */
        CALL setInterpolationPattern 'shell'

        /* Define variables */
        app_name = "webapp"
        region = "us-central1"

        /* Use shell-style variables */
        ADDRESS GCP 'LOAD-BALANCER \${app_name}-lb WITH
        backend_service "\${app_name}-backend" {
          protocol HTTP
        }
        END'
      `;

      const { spawn } = require('child_process');
      spawn.mockReturnValue({
        stdout: { on: jest.fn() },
        stderr: { on: jest.fn() },
        on: jest.fn((event, callback) => {
          if (event === 'close') callback(0);
        })
      });

      await interpreter.run(parse(script));

      const rc = interpreter.getVariable('RC');
      expect(rc).toBe(0);
    });

    test('should support batch-style interpolation pattern', async () => {

      const script = `
        /* Set batch-style interpolation */
        CALL setInterpolationPattern 'batch'

        /* Define variables */
        service_name = "api"

        /* Use batch-style variables */
        ADDRESS GCP 'LOAD-BALANCER %service_name%-lb WITH
        backend_service "%service_name%-backend" {
          protocol HTTP
        }
        END'
      `;

      const { spawn } = require('child_process');
      spawn.mockReturnValue({
        stdout: { on: jest.fn() },
        stderr: { on: jest.fn() },
        on: jest.fn((event, callback) => {
          if (event === 'close') callback(0);
        })
      });

      await interpreter.run(parse(script));

      const rc = interpreter.getVariable('RC');
      expect(rc).toBe(0);
    });
  });

  describe('Variable Interpolation - Non-Declarative Commands', () => {
    test('should interpolate variables in imperative Sheets commands', async () => {

      const script = `
        CALL setInterpolationPattern 'handlebars'

        spreadsheet_id = "abc123"
        sheet_name = "Users"

        ADDRESS GCP 'SHEETS {{spreadsheet_id}} SELECT * FROM {{sheet_name}}'
      `;

      // This will fail without Google credentials, but we can verify interpolation was attempted
      try {
        await interpreter.run(parse(script));
      } catch (e) {
        // Expected to fail without credentials, but interpolation should have occurred
      }
    });

    test('should interpolate variables in BigQuery commands', async () => {

      const script = `
        CALL setInterpolationPattern 'handlebars'

        dataset = "analytics"
        table_name = "events"

        ADDRESS GCP 'BIGQUERY CONNECT {{dataset}}'
      `;

      try {
        await interpreter.run(parse(script));
      } catch (e) {
        // Expected to fail without BigQuery setup
      }
    });
  });

  describe('REXX-based Logic with Declarative Blocks (Option A)', () => {
    test('should use REXX IF/THEN to compose different blocks', async () => {

      const script = `
        CALL setInterpolationPattern 'handlebars'

        env = "production"

        /* REXX handles conditionals */
        IF env = "production" THEN DO
          port = 443
          protocol = "HTTPS"
        END
        ELSE DO
          port = 80
          protocol = "HTTP"
        END

        /* Declarative block uses interpolated values */
        ADDRESS GCP 'LOAD-BALANCER {{env}}-lb WITH
        backend_service "{{env}}-backend" {
          protocol {{protocol}}
          health_check {
            port {{port}}
          }
        }
        END'
      `;

      const { spawn } = require('child_process');
      spawn.mockReturnValue({
        stdout: { on: jest.fn() },
        stderr: { on: jest.fn() },
        on: jest.fn((event, callback) => {
          if (event === 'close') callback(0);
        })
      });

      await interpreter.run(parse(script));

      const rc = interpreter.getVariable('RC');
      expect(rc).toBe(0);

      // Verify conditionals executed correctly
      const port = interpreter.getVariable('port');
      const protocol = interpreter.getVariable('protocol');
      expect(port).toBe(443);
      expect(protocol).toBe('HTTPS');
    });

    test('should use REXX DO loop to create multiple resources', async () => {

      const script = `
        CALL setInterpolationPattern 'handlebars'

        environments = "dev staging production"

        /* REXX handles loops */
        DO i = 1 TO WORDS(environments)
          env = WORD(environments, i)

          /* Create load balancer for each environment */
          ADDRESS GCP 'LOAD-BALANCER {{env}}-lb WITH
          backend_service "{{env}}-backend" {
            protocol HTTP
          }
          END'

          /* Check success */
          IF RC = 0 THEN DO
            SAY "Created" env "load balancer"
          END
        END
      `;

      const { spawn } = require('child_process');
      let callCount = 0;
      spawn.mockImplementation(() => {
        callCount++;
        return {
          stdout: { on: jest.fn() },
          stderr: { on: jest.fn() },
          on: jest.fn((event, callback) => {
            if (event === 'close') callback(0);
          })
        };
      });

      await interpreter.run(parse(script));

      // Should have created 3 load balancers (dev, staging, production)
      // Note: Actual call count depends on how many gcloud commands per LB
      expect(callCount).toBeGreaterThan(0);
    });
  });

  describe('Error Handling', () => {
    test('should handle malformed declarative syntax', async () => {

      const script = `
        ADDRESS GCP 'LOAD-BALANCER test-lb WITH
        backend_service "test-backend" {
          protocol HTTP
          # Missing closing brace
        END'
      `;

      // Should fail gracefully
      await expect(interpreter.run(parse(script))).rejects.toThrow();
    });

    test('should handle missing END delimiter', async () => {

      const script = `
        ADDRESS GCP 'LOAD-BALANCER test-lb WITH
        backend_service "test-backend" {
          protocol HTTP
        }
        '
      `;

      // Should fail due to missing END
      await expect(interpreter.run(parse(script))).rejects.toThrow();
    });
  });

  describe('Integration - Real-World Scenarios', () => {
    test('should create multi-region load balancer with variables', async () => {

      const script = `
        CALL setInterpolationPattern 'handlebars'

        /* Configuration variables */
        app = "webapp"
        env = "production"
        domain = "example.com"
        health_port = 80
        health_path = "/health"
        timeout = "30s"

        /* Create load balancer */
        ADDRESS GCP 'LOAD-BALANCER {{app}}-{{env}}-lb WITH
        backend_service "{{app}}-{{env}}-backend" {
          protocol HTTPS
          timeout {{timeout}}

          health_check {
            protocol HTTP
            port {{health_port}}
            request_path "{{health_path}}"
            check_interval 10s
          }

          cdn {
            enabled true
            cache_mode CACHE_ALL_STATIC
          }
        }

        url_map "{{app}}-{{env}}-map" {
          default_service {{app}}-{{env}}-backend
        }

        frontend {
          name {{app}}-{{env}}-frontend
          port 443
          protocol HTTPS

          ssl_certificate {
            managed true
            domains ["{{domain}}"]
          }
        }
        END'
      `;

      const { spawn } = require('child_process');
      spawn.mockReturnValue({
        stdout: { on: jest.fn() },
        stderr: { on: jest.fn() },
        on: jest.fn((event, callback) => {
          if (event === 'close') callback(0);
        })
      });

      await interpreter.run(parse(script));

      const rc = interpreter.getVariable('RC');
      expect(rc).toBe(0);
    });
  });
});
