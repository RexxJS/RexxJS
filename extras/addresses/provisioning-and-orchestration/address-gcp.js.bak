/**
 * @rexxjs-meta=GCP_ADDRESS_META
 * @provides: addressTarget=GCP
 * @interpreterHandlesInterpolation: true
 */

const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const { google } = require('googleapis');
const { parseCommand } = require('../shared-utils/index.js');
const { parseKeyValueParams } = require('../shared-utils/gcp-utils.js');

// Parse result chain syntax (command → variable)
const parseResultChain = (command) => {
  const chainMatch = command.match(/^(.+?)\s*→\s*(\w+)\s*$/);
  if (chainMatch) {
    return {
      command: chainMatch[1].trim(),
      resultVar: chainMatch[2].trim()
    };
  }
  return { command: command.trim(), resultVar: null };
};

// Replace @variable references with actual values
const resolveVariableReferences = (command, variableStore) => {
  return command.replace(/@(\w+)/g, (match, varName) => {
    if (variableStore && variableStore[varName]) {
      return JSON.stringify(variableStore[varName]);
    }
    return match;
  });
};

// Parse HEREDOC with @SECTION markers
const parseHeredocSections = (heredocContent) => {
  const sections = {};
  const lines = heredocContent.split('\n');
  let currentSection = 'main';
  let currentCommands = [];
  
  for (const line of lines) {
    const trimmed = line.trim();
    
    if (trimmed.startsWith('@SECTION ')) {
      // Save previous section
      if (currentCommands.length > 0) {
        sections[currentSection] = currentCommands.join('\n');
      }
      
      // Start new section
      currentSection = trimmed.substring(9).trim();
      currentCommands = [];
    } else if (trimmed && !trimmed.startsWith('#')) {
      // Add command to current section
      currentCommands.push(trimmed);
    }
  }
  
  // Save final section
  if (currentCommands.length > 0) {
    sections[currentSection] = currentCommands.join('\n');
  }
  
  return sections;
};

// Execute sectioned HEREDOC workflow
const executeSectionedWorkflow = async (sections, gcpHandler) => {
  const results = {};
  
  for (const [sectionName, commands] of Object.entries(sections)) {
    try {
      // Split commands by line and execute each
      const commandLines = commands.split('\n').filter(line => line.trim());
      const sectionResults = [];
      
      for (const command of commandLines) {
        const result = await gcpHandler.execute(command.trim());
        sectionResults.push(result);
      }
      
      results[sectionName] = {
        success: true,
        commands: commandLines,
        results: sectionResults,
        stdout: sectionResults.map(r => r.stdout || '').join('\n'),
        stderr: sectionResults.map(r => r.stderr || '').join('\n')
      };
    } catch (error) {
      results[sectionName] = {
        success: false,
        error: error.message,
        commands: commands.split('\n').filter(line => line.trim())
      };
    }
  }
  
  return results;
};

const GCP_ADDRESS_META = {
  name: 'GCP',
  description: 'Google Cloud Platform unified orchestration interface with enhanced grammar and rate limiting',
  version: '2.1.0',
  provides: { addressTarget: 'GCP' },
  libraryMetadata: {
    interpreterHandlesInterpolation: true
  },
  services: ['SHEETS', 'DOCS', 'SLIDES', 'APPS_SCRIPT', 'BIGQUERY', 'BILLING', 'FIRESTORE', 'STORAGE', 'PUBSUB', 'FUNCTIONS', 'RUN', 'COMPUTE', 'MONITORING', 'LOGGING', 'IAM', 'SQL', 'RATELIMIT'],
  grammar: {
    features: ['aliases', 'result-chains', 'natural-language', 'batch-operations', 'sections', 'rate-limiting'],
    examples: {
      'alias-usage': 'SHEETS ALIAS orders="1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms"',
      'result-chains': 'SHEETS SELECT * FROM orders.\'Sales\' → sales_data',
      'natural-language': 'SHEETS SELECT * FROM \'Orders\' WHERE amount ABOVE 1000',
      'batch-operations': 'SHEETS BATCH ["SELECT * FROM \'Q1\'", "SELECT * FROM \'Q2\'"]',
      'standardized-params': 'STORAGE UPLOAD file="report.pdf" bucket="company-docs" as="reports/monthly.pdf"',
      'rate-limiting': 'RATELIMIT SET sheets 50 60',
      'sectioned-workflow': `@SECTION data-extraction
SHEETS SELECT * FROM orders WHERE date IS today → daily_orders

@SECTION analytics  
BIGQUERY INSERT INTO staging SELECT * FROM @daily_orders

@SECTION notifications
PUBSUB PUBLISH topic="alerts" message="Daily report ready"`
    },
    'rate-limiting': {
      description: 'Local rate limiting for all GCP API calls',
      commands: {
        'RATELIMIT ENABLE': 'Enable rate limiting for all services',
        'RATELIMIT DISABLE': 'Disable rate limiting for all services',
        'RATELIMIT STATUS': 'Show current rate limit status and usage',
        'RATELIMIT RESET [service]': 'Reset rate limit counters',
        'RATELIMIT SET service requests window_seconds': 'Set rate limit for a service',
        'RATELIMIT HELP': 'Show help for rate limiting commands'
      },
      services: ['global', 'sheets', 'bigquery', 'firestore', 'storage', 'pubsub', 'functions', 'run', 'compute', 'monitoring', 'logging', 'iam', 'sql', 'vpc', 'dns', 'secrets', 'kms', 'tasks', 'scheduler', 'artifactRegistry', 'gke'],
      defaults: {
        requests: 100,
        windowSeconds: 60,
        enabled: false
      }
    }
  }
};

// Global instance for handler reuse
let gcpHandler = null;

// Service-specific handlers
let serviceHandlers = null;

// Global variable store for result chains
let globalVariableStore = {};

// Global alias store for sheet references
let globalAliasStore = {};

// Rate limiting management
class RateLimiter {
  constructor() {
    this.limits = {
      global: { requests: 100, window: 60000 }, // 100 requests per minute by default
      sheets: { requests: 100, window: 60000 },
      docs: { requests: 60, window: 60000 }, // Google Docs API: 60 requests per minute
      slides: { requests: 100, window: 60000 }, // Google Slides API: 100 requests per minute
      apps_script: { requests: 20, window: 60000 }, // Apps Script API: 20 requests per 60 seconds
      bigquery: { requests: 100, window: 60000 },
      billing: { requests: 60, window: 60000 },
      storage: { requests: 100, window: 60000 },
      firestore: { requests: 100, window: 60000 },
      pubsub: { requests: 100, window: 60000 },
      functions: { requests: 100, window: 60000 },
      run: { requests: 100, window: 60000 },
      compute: { requests: 100, window: 60000 },
      monitoring: { requests: 100, window: 60000 },
      logging: { requests: 100, window: 60000 },
      iam: { requests: 100, window: 60000 },
      sql: { requests: 100, window: 60000 },
      vpc: { requests: 100, window: 60000 },
      dns: { requests: 100, window: 60000 },
      secrets: { requests: 100, window: 60000 },
      kms: { requests: 100, window: 60000 },
      tasks: { requests: 100, window: 60000 },
      scheduler: { requests: 100, window: 60000 },
      artifactRegistry: { requests: 100, window: 60000 },
      gke: { requests: 100, window: 60000 },
      loadBalancing: { requests: 100, window: 60000 },
      cdn: { requests: 100, window: 60000 },
      armor: { requests: 100, window: 60000 },
      memorystore: { requests: 100, window: 60000 },
      bigtable: { requests: 100, window: 60000 },
      spanner: { requests: 100, window: 60000 }
    };

    this.counters = {};
    this.enabled = false;
  }

  setLimit(service, requests, windowMs) {
    if (service === 'global' || this.limits[service]) {
      this.limits[service] = { requests, window: windowMs };
      // Reset counter for this service
      delete this.counters[service];
      return true;
    }
    return false;
  }

  enable() {
    this.enabled = true;
  }

  disable() {
    this.enabled = false;
  }

  async checkLimit(service = 'global') {
    if (!this.enabled) return true;

    const now = Date.now();
    const limit = this.limits[service] || this.limits.global;
    
    if (!this.counters[service]) {
      this.counters[service] = { count: 0, windowStart: now };
    }

    const counter = this.counters[service];
    
    // Reset window if expired
    if (now - counter.windowStart >= limit.window) {
      counter.count = 0;
      counter.windowStart = now;
    }

    // Check if limit exceeded
    if (counter.count >= limit.requests) {
      const timeUntilReset = limit.window - (now - counter.windowStart);
      throw new Error(`Rate limit exceeded for ${service}. Try again in ${Math.ceil(timeUntilReset / 1000)} seconds. Limit: ${limit.requests} requests per ${limit.window / 1000} seconds.`);
    }

    counter.count++;
    return true;
  }

  getStatus() {
    const now = Date.now();
    const status = { enabled: this.enabled, limits: this.limits, current: {} };
    
    for (const [service, counter] of Object.entries(this.counters)) {
      const limit = this.limits[service] || this.limits.global;
      const timeInWindow = now - counter.windowStart;
      const remaining = Math.max(0, limit.requests - counter.count);
      const resetIn = Math.max(0, limit.window - timeInWindow);
      
      status.current[service] = {
        used: counter.count,
        remaining,
        resetInMs: resetIn,
        resetInSeconds: Math.ceil(resetIn / 1000)
      };
    }
    
    return status;
  }

  reset(service = null) {
    if (service) {
      delete this.counters[service];
    } else {
      this.counters = {};
    }
  }
}

let globalRateLimiter = new RateLimiter();

// Initialize handlers on first use
const initGcpHandler = async () => {
  if (!gcpHandler) {
    gcpHandler = new UnifiedGcpHandler();
    await gcpHandler.initialize();
  }
  return gcpHandler;
};

// Variable interpolation - resolve {variable} patterns from context
// Implements same pattern as expectations-address.js (lines 706-729)
function resolveVariablesInCommand(commandString, context) {
  if (!context || typeof context !== 'object') return commandString;

  // Replace {variable} patterns with actual values from context
  return commandString.replace(/\{(\w+(?:\.\w+)*)\}/g, (match, path) => {
    const keys = path.split('.');
    let value = context;

    for (const key of keys) {
      if (value == null) return match; // Keep original if not found
      value = value[key];
    }

    return value !== undefined ? value : match;
  });
}

// ADDRESS target handler function
async function ADDRESS_GCP_HANDLER(commandOrMethod, paramsOrContext, sourceContext) {
  const handler = await initGcpHandler();

  // Handle command-string style (primary usage)
  // When called from RexxJS interpreter: (commandString, contextObject, sourceContextObject)
  // When called as method: (methodName, paramsObject)
  if (typeof commandOrMethod === 'string' &&
      (!paramsOrContext || typeof paramsOrContext === 'object' && !paramsOrContext.params)) {

    // Interpolate {variable} patterns from context (global variable pool)
    let commandString = resolveVariablesInCommand(commandOrMethod, paramsOrContext);

    // Check if this is a HEREDOC with @SECTION markers
    if (commandString.includes('@SECTION ')) {
      const sections = parseHeredocSections(commandString);
      return await executeSectionedWorkflow(sections, handler);
    }

    return await handler.execute(commandString);
  }

  // Handle method-call style (backward compatibility)
  return await handler.handle(commandOrMethod, paramsOrContext);
}

// ============================================
// Service-Specific Command Languages
// ============================================

// ============================================================================
// SheetsHandler - Now loaded lazily from gcp-handlers/sheets-handler.js
// ============================================================================

// ============================================================================
// DocsHandler - Now loaded lazily from gcp-handlers/docs-handler.js
// ============================================================================

// ============================================================================
// SlidesHandler - Now loaded lazily from gcp-handlers/slides-handler.js
// ============================================================================

// ============================================================================
// AppsScriptHandler - Now loaded lazily from gcp-handlers/apps-script-handler.js
// ============================================================================

// ============================================================================
// BigQueryHandler - Now loaded lazily from gcp-handlers/bigquery-handler.js
// ============================================================================

class FirestoreHandler {
  constructor(parent) {
    this.parent = parent;
    this.firestore = null;
    this.currentDatabase = null;
  }

  async initialize() {
    try {
      const { Firestore } = require('@google-cloud/firestore');
      this.firestore = new Firestore({
        projectId: this.parent.project
      });
    } catch (e) {
      // Firestore SDK not available
    }
  }

  async handle(command) {
    const trimmed = command.trim();

    // Path-based operations
    if (trimmed.startsWith('GET ')) {
      return await this.get(trimmed.substring(4));
    }
    if (trimmed.startsWith('SET ')) {
      return await this.set(trimmed.substring(4));
    }
    if (trimmed.startsWith('DELETE ')) {
      return await this.delete(trimmed.substring(7));
    }
    if (trimmed.startsWith('QUERY ')) {
      return await this.query(trimmed.substring(6));
    }
    if (trimmed.startsWith('WATCH ')) {
      return await this.watch(trimmed.substring(6));
    }

    throw new Error(`Unknown FIRESTORE command: ${trimmed.split(' ')[0]}`);
  }

  async get(path) {
    if (this.firestore) {
      const doc = await this.firestore.doc(path).get();
      return {
        success: true,
        exists: doc.exists,
        data: doc.exists ? doc.data() : null,
        id: doc.id,
        path: path
      };
    }

    // Fallback to REST API
    // TODO: Implement REST fallback
    throw new Error('Firestore SDK not available');
  }
}

class StorageHandler {
  constructor(parent) {
    this.parent = parent;
    this.storage = null;
  }

  async initialize() {
    try {
      const { Storage } = require('@google-cloud/storage');
      this.storage = new Storage({
        projectId: this.parent.project
      });
    } catch (e) {
      // Storage SDK not available, will use gsutil
    }
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    if (upperCommand.startsWith('UPLOAD ')) {
      return await this.upload(trimmed.substring(7));
    }
    if (upperCommand.startsWith('DOWNLOAD ')) {
      return await this.download(trimmed.substring(9));
    }
    if (upperCommand.startsWith('LIST ')) {
      return await this.list(trimmed.substring(5));
    }
    if (upperCommand.startsWith('DELETE ')) {
      return await this.delete(trimmed.substring(7));
    }
    if (upperCommand.startsWith('CREATE BUCKET ')) {
      return await this.createBucket(trimmed.substring(14));
    }

    throw new Error(`Unknown STORAGE command: ${trimmed.split(' ')[0]}`);
  }

  async upload(params) {
    // Parse standardized syntax: UPLOAD file="path" bucket="name" [as="remote-path"]
    const parsedParams = parseKeyValueParams(params);
    
    if (parsedParams.file && parsedParams.bucket) {
      // New standardized format
      const localFile = parsedParams.file;
      const bucket = parsedParams.bucket;
      const destination = parsedParams.as || path.basename(localFile);
      
      return await this.executeUpload(localFile, bucket, destination);
    }
    
    // Legacy format: FILE 'path' TO bucket='name' [AS 'remote-path']
    const match = params.match(/FILE\s+['"]([^'"]+)['"]\s+TO\s+bucket=['"]([^'"]+)['"](?:\s+AS\s+['"]([^'"]+)['"])?/i);

    if (!match) {
      throw new Error('Invalid UPLOAD syntax. Use: UPLOAD file="path" bucket="name" [as="remote-path"] or legacy FILE "path" TO bucket="name"');
    }

    const [_, localFile, bucket, remotePath] = match;
    const destination = remotePath || path.basename(localFile);
    
    return await this.executeUpload(localFile, bucket, destination);
  }
  
  async executeUpload(localFile, bucket, destination) {
    if (this.storage) {
      await this.storage.bucket(bucket).upload(localFile, {
        destination: destination
      });

      return {
        success: true,
        bucket: bucket,
        file: destination,
        size: fs.statSync(localFile).size
      };
    } else {
      // Fallback to gsutil
      const result = await this.parent.execCommand('gsutil', [
        'cp', localFile, `gs://${bucket}/${destination}`
      ]);

      return {
        success: result.success,
        bucket: bucket,
        file: destination
      };
    }
  }
}

class PubSubHandler {
  constructor(parent) {
    this.parent = parent;
    this.pubsub = null;
  }

  async initialize() {
    try {
      const { PubSub } = require('@google-cloud/pubsub');
      this.pubsub = new PubSub({
        projectId: this.parent.project
      });
    } catch (e) {
      // PubSub SDK not available
    }
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    if (upperCommand.startsWith('CREATE TOPIC ')) {
      return await this.createTopic(trimmed.substring(13));
    }
    if (upperCommand.startsWith('PUBLISH ')) {
      return await this.publish(trimmed.substring(8));
    }
    if (upperCommand.startsWith('SUBSCRIBE ')) {
      return await this.subscribe(trimmed.substring(10));
    }
    if (upperCommand.startsWith('PULL ')) {
      return await this.pull(trimmed.substring(5));
    }

    throw new Error(`Unknown PUBSUB command: ${trimmed.split(' ')[0]}`);
  }

  async publish(params) {
    // Parse standardized syntax: PUBLISH topic="name" message="data"
    const parsedParams = parseKeyValueParams(params);
    
    if (parsedParams.topic && parsedParams.message) {
      // New standardized format
      return await this.executePublish(parsedParams.topic, parsedParams.message);
    }
    
    // Legacy format: topic MESSAGE 'data'
    const match = params.match(/([\w-]+)\s+MESSAGE\s+['"](.+)['"]$/i);

    if (!match) {
      throw new Error('Invalid PUBLISH syntax. Use: PUBLISH topic="name" message="data" or legacy topic MESSAGE "data"');
    }

    const [_, topic, message] = match;
    return await this.executePublish(topic, message);
  }
  
  async executePublish(topic, message) {
    if (this.pubsub) {
      const messageId = await this.pubsub.topic(topic).publish(Buffer.from(message));
      return {
        success: true,
        messageId: messageId,
        topic: topic
      };
    } else {
      // Fallback to gcloud
      const result = await this.parent.execCommand('gcloud', [
        'pubsub', 'topics', 'publish', topic,
        '--message', message
      ]);

      return {
        success: result.success,
        topic: topic
      };
    }
  }
}

// Legacy cloud functions and cloud run handlers remain
class FunctionsHandler {
  constructor(parent) {
    this.parent = parent;
  }

  async handle(command) {
    const trimmed = command.trim();
    const parts = trimmed.split(/\s+/);
    const action = parts[0].toUpperCase();

    switch (action) {
      case 'DEPLOY':
        return await this.deploy(parts.slice(1));
      case 'DELETE':
        return await this.delete(parts[1]);
      case 'INVOKE':
        return await this.invoke(parts.slice(1));
      case 'LIST':
        return await this.list();
      default:
        throw new Error(`Unknown FUNCTIONS command: ${action}`);
    }
  }

  async deploy(params) {
    // Deploy a cloud function
    // DEPLOY name SOURCE 'path' TRIGGER 'http' RUNTIME 'python311' REGION 'us-central1' ENTRYPOINT 'main'
    const name = params[0];
    const sourceIndex = params.findIndex(p => p.toUpperCase() === 'SOURCE');
    const triggerIndex = params.findIndex(p => p.toUpperCase() === 'TRIGGER');
    const runtimeIndex = params.findIndex(p => p.toUpperCase() === 'RUNTIME');
    const regionIndex = params.findIndex(p => p.toUpperCase() === 'REGION');
    const entrypointIndex = params.findIndex(p => p.toUpperCase() === 'ENTRYPOINT');

    const source = sourceIndex >= 0 ? params[sourceIndex + 1].replace(/['"]/g, '') : '.';
    const trigger = triggerIndex >= 0 ? params[triggerIndex + 1].replace(/['"]/g, '') : 'http';
    const runtime = runtimeIndex >= 0 ? params[runtimeIndex + 1].replace(/['"]/g, '') : 'python311';
    const region = regionIndex >= 0 ? params[regionIndex + 1].replace(/['"]/g, '') : 'us-central1';
    const entrypoint = entrypointIndex >= 0 ? params[entrypointIndex + 1].replace(/['"]/g, '') : name.replace(/-/g, '_');

    const args = ['functions', 'deploy', name];
    args.push('--gen2');  // Use 2nd generation Cloud Functions
    args.push('--runtime', runtime);
    args.push('--source', source);
    args.push('--entry-point', entrypoint);
    args.push('--region', region);

    if (trigger === 'http') {
      args.push('--trigger-http', '--allow-unauthenticated');
    } else if (trigger.includes(':')) {
      const [type, resource] = trigger.split(':');
      args.push(`--trigger-${type}`, resource);
    }

    if (this.parent.project) args.push('--project', this.parent.project);

    const result = await this.parent.execCommand('gcloud', args);

    // If deploy succeeded, get function details in JSON format
    if (result.success) {
      const describeArgs = ['functions', 'describe', name, '--region', region, '--format=json'];
      if (this.parent.project) describeArgs.push('--project', this.parent.project);

      const describeResult = await this.parent.execCommand('gcloud', describeArgs);

      if (describeResult.success && describeResult.stdout) {
        try {
          const functionData = JSON.parse(describeResult.stdout);
          return {
            success: true,
            name: name,
            trigger: trigger,
            runtime: runtime,
            region: region,
            entrypoint: entrypoint,
            url: functionData.serviceConfig?.uri || null,
            state: functionData.state,
            updateTime: functionData.updateTime,
            data: functionData,
            stdout: result.stdout,
            stderr: result.stderr
          };
        } catch (e) {
          // JSON parse failed, return basic result
        }
      }
    }

    return {
      success: result.success,
      name: name,
      trigger: trigger,
      runtime: runtime,
      region: region,
      entrypoint: entrypoint,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async delete(functionName) {
    // DELETE function_name [REGION region]
    const args = ['functions', 'delete', functionName, '--quiet'];

    // Note: For 2nd gen functions, region is required; for 1st gen, it's optional
    // We'll let gcloud handle the default
    if (this.parent.region) args.push('--region', this.parent.region);
    if (this.parent.project) args.push('--project', this.parent.project);

    const result = await this.parent.execCommand('gcloud', args);

    return {
      success: result.success,
      name: functionName,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async invoke(params) {
    // INVOKE function_name [DATA '{"key":"value"}']
    const name = params[0];
    const dataIndex = params.findIndex(p => p.toUpperCase() === 'DATA');
    const data = dataIndex >= 0 ? params[dataIndex + 1].replace(/^['"]|['"]$/g, '') : null;

    const args = ['functions', 'call', name];

    if (data) args.push('--data', data);
    if (this.parent.region) args.push('--region', this.parent.region);
    if (this.parent.project) args.push('--project', this.parent.project);

    const result = await this.parent.execCommand('gcloud', args);

    return {
      success: result.success,
      name: name,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async list() {
    // LIST all functions
    const args = ['functions', 'list', '--format', 'json'];

    if (this.parent.project) args.push('--project', this.parent.project);

    const result = await this.parent.execCommand('gcloud', args);

    let functions = [];
    if (result.success && result.stdout) {
      try {
        functions = JSON.parse(result.stdout);
      } catch (e) {
        // Failed to parse JSON
      }
    }

    return {
      success: result.success,
      functions: functions,
      count: functions.length,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }
}

class CloudRunHandler {
  constructor(parent) {
    this.parent = parent;
  }

  async handle(command) {
    const trimmed = command.trim();
    const parts = trimmed.split(/\s+/);
    const action = parts[0].toUpperCase();

    switch (action) {
      case 'DEPLOY':
        return await this.deploy(parts.slice(1));
      case 'DELETE':
        return await this.delete(parts[1]);
      case 'UPDATE':
        return await this.update(parts.slice(1));
      case 'LIST':
        return await this.list();
      default:
        throw new Error(`Unknown RUN command: ${action}`);
    }
  }

  async deploy(params) {
    // DEPLOY name IMAGE 'image' REGION 'region'
    const name = params[0];
    const imageIndex = params.findIndex(p => p.toUpperCase() === 'IMAGE');
    const regionIndex = params.findIndex(p => p.toUpperCase() === 'REGION');

    if (imageIndex < 0) {
      throw new Error('IMAGE is required for Cloud Run deployment');
    }

    const image = params[imageIndex + 1].replace(/['"]/g, '');
    const region = regionIndex >= 0 ? params[regionIndex + 1].replace(/['"]/g, '') : 'us-central1';

    const args = ['run', 'deploy', name];
    args.push('--image', image);
    args.push('--region', region);
    args.push('--platform', 'managed');
    args.push('--allow-unauthenticated');

    if (this.parent.project) args.push('--project', this.parent.project);

    const result = await this.parent.execCommand('gcloud', args);

    // If deploy succeeded, get service details in JSON format
    if (result.success) {
      const describeArgs = ['run', 'services', 'describe', name, '--region', region, '--platform', 'managed', '--format=json'];
      if (this.parent.project) describeArgs.push('--project', this.parent.project);

      const describeResult = await this.parent.execCommand('gcloud', describeArgs);

      if (describeResult.success && describeResult.stdout) {
        try {
          const serviceData = JSON.parse(describeResult.stdout);
          return {
            success: true,
            name: name,
            image: image,
            region: region,
            url: serviceData.status?.url || null,
            ready: serviceData.status?.conditions?.find(c => c.type === 'Ready')?.status === 'True',
            data: serviceData,
            stdout: result.stdout,
            stderr: result.stderr
          };
        } catch (e) {
          // JSON parse failed, return basic result
        }
      }
    }

    return {
      success: result.success,
      name: name,
      image: image,
      region: region,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async delete(serviceName) {
    // DELETE service_name [REGION region]
    const args = ['run', 'services', 'delete', serviceName];
    args.push('--platform', 'managed');
    args.push('--region', this.parent.region || 'us-central1');
    args.push('--quiet');

    if (this.parent.project) args.push('--project', this.parent.project);

    const result = await this.parent.execCommand('gcloud', args);

    return {
      success: result.success,
      name: serviceName,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }
}

// ComputeEngineHandler - extracted to gcp-handlers/compute-engine-handler.js

// Placeholder for inline class definition (extracted)
  constructor(parent) {
    this.parent = parent;
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    // Instance lifecycle management
    if (upperCommand.startsWith('CREATE INSTANCE ') || upperCommand.startsWith('CREATE ')) {
      return await this.createInstance(trimmed);
    }
    if (upperCommand.startsWith('START ')) {
      return await this.startInstance(trimmed.substring(6).trim());
    }
    if (upperCommand.startsWith('STOP ')) {
      return await this.stopInstance(trimmed.substring(5).trim());
    }
    if (upperCommand.startsWith('DELETE INSTANCE ') || upperCommand.startsWith('DELETE ')) {
      return await this.deleteInstance(trimmed);
    }
    if (upperCommand.startsWith('LIST') || upperCommand === '') {
      return await this.listInstances(trimmed);
    }
    if (upperCommand.startsWith('DESCRIBE ') || upperCommand.startsWith('GET ')) {
      return await this.describeInstance(trimmed);
    }
    if (upperCommand.startsWith('RESET ')) {
      return await this.resetInstance(trimmed.substring(6).trim());
    }

    // Instance templates and groups
    if (upperCommand.startsWith('CREATE TEMPLATE ')) {
      return await this.createTemplate(trimmed.substring(16).trim());
    }
    if (upperCommand.startsWith('CREATE INSTANCE-GROUP ')) {
      return await this.createInstanceGroup(trimmed.substring(22).trim());
    }
    if (upperCommand.startsWith('AUTOSCALE ')) {
      return await this.autoscale(trimmed.substring(10).trim());
    }

    throw new Error(`Unknown COMPUTE command: ${trimmed.split(' ')[0]}`);
  }

  async createInstance(command) {
    // Parse: CREATE [INSTANCE] name [MACHINE type] [ZONE zone] [IMAGE image] [params...]
    const params = parseKeyValueParams(command);

    // Extract positional arguments for name (first word after CREATE/CREATE INSTANCE)
    const parts = command.trim().split(/\s+/);
    let nameIdx = parts[0].toUpperCase() === 'CREATE' ? (parts[1].toUpperCase() === 'INSTANCE' ? 2 : 1) : 0;
    const instanceName = params.name || parts[nameIdx];

    const machineType = params.machine || params.type || 'e2-micro';
    const zone = params.zone || 'us-central1-a';
    const image = params.image || 'debian-11';
    const diskSize = params.disk || '10';

    const cmdParts = [
      'gcloud', 'compute', 'instances', 'create', instanceName,
      '--machine-type', machineType,
      '--zone', zone,
      '--boot-disk-size', diskSize + 'GB',
      '--format', 'json'
    ];

    // Handle image (can be family or specific image)
    if (image.includes('/')) {
      cmdParts.push('--image', image);
    } else if (image.startsWith('debian') || image.startsWith('ubuntu') || image.startsWith('centos')) {
      cmdParts.push('--image-family', image);
      if (image.startsWith('debian')) {
        cmdParts.push('--image-project', 'debian-cloud');
      } else if (image.startsWith('ubuntu')) {
        cmdParts.push('--image-project', 'ubuntu-os-cloud');
      } else if (image.startsWith('centos')) {
        cmdParts.push('--image-project', 'centos-cloud');
      }
    } else {
      cmdParts.push('--image', image);
    }

    // Add optional parameters
    if (params.preemptible === 'true') {
      cmdParts.push('--preemptible');
    }
    if (params.tags) {
      cmdParts.push('--tags', params.tags);
    }
    if (params.labels) {
      cmdParts.push('--labels', params.labels);
    }
    if (params.network) {
      cmdParts.push('--network', params.network);
    }
    if (params.subnet) {
      cmdParts.push('--subnet', params.subnet);
    }

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      let instanceData = null;
      try {
        const parsed = JSON.parse(result.stdout);
        instanceData = Array.isArray(parsed) ? parsed[0] : parsed;
      } catch (e) {
        // JSON parsing failed, use text output
      }

      return {
        success: true,
        action: 'created',
        instance: instanceName,
        zone: zone,
        machineType: machineType,
        image: image,
        data: instanceData,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create instance: ${result.stderr || result.stdout}`);
  }

  async startInstance(params) {
    // Parse: instance-name [zone=us-central1-a]
    const parsed = parseKeyValueParams(params);
    const parts = params.trim().split(/\s+/);
    const instanceName = parsed.instance || parts[0];
    const zone = parsed.zone || 'us-central1-a';

    const result = await this.executeGcloud([
      'gcloud', 'compute', 'instances', 'start', instanceName,
      '--zone', zone,
      '--format', 'json'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'started',
        instance: instanceName,
        zone: zone,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to start instance: ${result.stderr || result.stdout}`);
  }

  async stopInstance(params) {
    // Parse: instance-name [zone=us-central1-a]
    const parsed = parseKeyValueParams(params);
    const parts = params.trim().split(/\s+/);
    const instanceName = parsed.instance || parts[0];
    const zone = parsed.zone || 'us-central1-a';

    const result = await this.executeGcloud([
      'gcloud', 'compute', 'instances', 'stop', instanceName,
      '--zone', zone,
      '--format', 'json'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'stopped',
        instance: instanceName,
        zone: zone,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to stop instance: ${result.stderr || result.stdout}`);
  }

  async deleteInstance(command) {
    // Parse: DELETE [INSTANCE] name [zone=us-central1-a]
    const params = parseKeyValueParams(command);
    const parts = command.trim().split(/\s+/);
    let nameIdx = parts[0].toUpperCase() === 'DELETE' ? (parts[1].toUpperCase() === 'INSTANCE' ? 2 : 1) : 0;
    const instanceName = params.instance || params.name || parts[nameIdx];
    const zone = params.zone || 'us-central1-a';

    const result = await this.executeGcloud([
      'gcloud', 'compute', 'instances', 'delete', instanceName,
      '--zone', zone,
      '--quiet', // Skip confirmation
      '--format', 'json'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'deleted',
        instance: instanceName,
        zone: zone,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to delete instance: ${result.stderr || result.stdout}`);
  }

  async listInstances(command) {
    // Parse: LIST [zone=zone] [filter="filter"]
    const params = parseKeyValueParams(command);
    const cmdParts = ['gcloud', 'compute', 'instances', 'list', '--format', 'json'];

    if (params.zone) {
      cmdParts.push('--zones', params.zone);
    }
    if (params.filter) {
      cmdParts.push('--filter', params.filter);
    }

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      let instances = [];
      try {
        instances = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        action: 'list',
        instances: instances,
        count: instances.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list instances: ${result.stderr || result.stdout}`);
  }

  async describeInstance(command) {
    // Parse: DESCRIBE instance-name [zone=us-central1-a] or GET instance-name [zone=us-central1-a]
    const params = parseKeyValueParams(command);
    const parts = command.trim().split(/\s+/);
    const instanceName = params.instance || params.name || parts[1];
    const zone = params.zone || 'us-central1-a';

    const result = await this.executeGcloud([
      'gcloud', 'compute', 'instances', 'describe', instanceName,
      '--zone', zone,
      '--format', 'json'
    ]);

    if (result.success) {
      let instanceData = null;
      try {
        instanceData = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        action: 'describe',
        instance: instanceName,
        zone: zone,
        data: instanceData,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to describe instance: ${result.stderr || result.stdout}`);
  }

  async resetInstance(params) {
    // Parse: instance-name [zone=us-central1-a]
    const parsed = parseKeyValueParams(params);
    const parts = params.trim().split(/\s+/);
    const instanceName = parsed.instance || parts[0];
    const zone = parsed.zone || 'us-central1-a';

    const result = await this.executeGcloud([
      'gcloud', 'compute', 'instances', 'reset', instanceName,
      '--zone', zone,
      '--format', 'json'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'reset',
        instance: instanceName,
        zone: zone,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to reset instance: ${result.stderr || result.stdout}`);
  }

  async createTemplate(params) {
    // Simplified implementation for instance templates
    throw new Error('Instance templates not yet implemented. Use CREATE INSTANCE for basic VMs.');
  }

  async createInstanceGroup(params) {
    // Simplified implementation for instance groups
    throw new Error('Instance groups not yet implemented. Use CREATE INSTANCE for basic VMs.');
  }

  async autoscale(params) {
    // Simplified implementation for autoscaling
    throw new Error('Autoscaling not yet implemented. Use CREATE INSTANCE for basic VMs.');
  }

  async executeGcloud(cmdParts) {
    return new Promise((resolve) => {
      const process = spawn(cmdParts[0], cmdParts.slice(1), {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({
          success: code === 0,
          code,
          stdout: stdout.trim(),
          stderr: stderr.trim()
        });
      });

      process.on('error', (error) => {
        resolve({
          success: false,
          code: -1,
          stdout: '',
          stderr: error.message
        });
      });
    });
  }
}

// ============================================
// Cloud Monitoring Handler
// ============================================

class MonitoringHandler {
  constructor(parent) {
    this.parent = parent;
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    if (upperCommand.startsWith('CREATE METRIC ')) {
      return await this.createMetric(trimmed.substring(14).trim());
    }
    if (upperCommand.startsWith('WRITE ')) {
      return await this.writeMetric(trimmed.substring(6).trim());
    }
    if (upperCommand.startsWith('CREATE ALERT ')) {
      return await this.createAlert(trimmed.substring(13).trim());
    }
    if (upperCommand.startsWith('CREATE UPTIME-CHECK ')) {
      return await this.createUptimeCheck(trimmed.substring(20).trim());
    }
    if (upperCommand.startsWith('LIST METRICS') || upperCommand === 'LIST') {
      return await this.listMetrics(trimmed);
    }
    if (upperCommand.startsWith('READ ')) {
      return await this.readMetrics(trimmed.substring(5).trim());
    }

    throw new Error(`Unknown MONITORING command: ${trimmed.split(' ')[0]}`);
  }

  async createMetric(params) {
    // Simplified: Custom metrics require Monitoring API
    // For now, return placeholder
    const parsed = parseKeyValueParams(params);
    const parts = params.trim().split(/\s+/);
    const metricName = parsed.name || parts[0];
    const metricType = parsed.type || 'gauge';

    return {
      success: true,
      action: 'create_metric',
      metric: metricName,
      type: metricType,
      message: 'Custom metric creation requires Monitoring API client library. Use gcloud or API directly.',
      note: 'This is a placeholder. Implement with @google-cloud/monitoring SDK for production use.'
    };
  }

  async writeMetric(params) {
    // Placeholder for writing metric data
    const parsed = parseKeyValueParams(params);

    return {
      success: true,
      action: 'write_metric',
      metric: parsed.metric,
      value: parsed.value,
      message: 'Metric writing requires Monitoring API client library.',
      note: 'This is a placeholder. Implement with @google-cloud/monitoring SDK for production use.'
    };
  }

  async createAlert(params) {
    // Simplified: Alert policies require Monitoring API
    const parsed = parseKeyValueParams(params);
    const alertName = parsed.name || params.split(/\s+/)[0];

    return {
      success: true,
      action: 'create_alert',
      alert: alertName,
      message: 'Alert policy creation requires Monitoring API client library.',
      note: 'This is a placeholder. Implement with @google-cloud/monitoring SDK for production use.'
    };
  }

  async createUptimeCheck(params) {
    // Simplified: Uptime checks require Monitoring API
    const parsed = parseKeyValueParams(params);
    const checkName = parsed.name || params.split(/\s+/)[0];
    const url = parsed.url;

    return {
      success: true,
      action: 'create_uptime_check',
      check: checkName,
      url: url,
      message: 'Uptime check creation requires Monitoring API client library.',
      note: 'This is a placeholder. Implement with @google-cloud/monitoring SDK for production use.'
    };
  }

  async listMetrics(params) {
    // Use gcloud to list metric descriptors
    const parsed = parseKeyValueParams(params);
    const filter = parsed.filter || 'metric.type:custom.googleapis.com/*';

    const result = await this.executeGcloud([
      'gcloud', 'monitoring', 'metrics-descriptors', 'list',
      '--filter', filter,
      '--format', 'json'
    ]);

    if (result.success) {
      let metrics = [];
      try {
        metrics = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        action: 'list_metrics',
        metrics: metrics,
        count: metrics.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list metrics: ${result.stderr || result.stdout}`);
  }

  async readMetrics(params) {
    // Placeholder for reading time series data
    const parsed = parseKeyValueParams(params);

    return {
      success: true,
      action: 'read_metrics',
      metric: parsed.metric,
      message: 'Time series reading requires Monitoring API client library.',
      note: 'This is a placeholder. Implement with @google-cloud/monitoring SDK for production use.'
    };
  }

  async executeGcloud(cmdParts) {
    return new Promise((resolve) => {
      const process = spawn(cmdParts[0], cmdParts.slice(1), {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({
          success: code === 0,
          code,
          stdout: stdout.trim(),
          stderr: stderr.trim()
        });
      });

      process.on('error', (error) => {
        resolve({
          success: false,
          code: -1,
          stdout: '',
          stderr: error.message
        });
      });
    });
  }
}

// ============================================
// Cloud Logging Handler
// ============================================

class LoggingHandler {
  constructor(parent) {
    this.parent = parent;
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    if (upperCommand.startsWith('READ ')) {
      return await this.readLogs(trimmed.substring(5).trim());
    }
    if (upperCommand.startsWith('CREATE SINK ')) {
      return await this.createSink(trimmed.substring(12).trim());
    }
    if (upperCommand.startsWith('CREATE METRIC ')) {
      return await this.createLogMetric(trimmed.substring(14).trim());
    }
    if (upperCommand.startsWith('LIST SINKS') || upperCommand === 'LIST') {
      return await this.listSinks();
    }
    if (upperCommand.startsWith('DELETE SINK ')) {
      return await this.deleteSink(trimmed.substring(12).trim());
    }

    throw new Error(`Unknown LOGGING command: ${trimmed.split(' ')[0]}`);
  }

  async readLogs(params) {
    // Parse: FILTER "filter" [LIMIT n] [TIME-RANGE range]
    const parsed = parseKeyValueParams(params);
    const filter = parsed.filter || params.split(/\s+/)[0];
    const limit = parsed.limit || '50';

    const cmdParts = [
      'gcloud', 'logging', 'read',
      filter,
      '--limit', limit,
      '--format', 'json'
    ];

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      let logs = [];
      try {
        logs = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        action: 'read_logs',
        logs: logs,
        count: logs.length,
        filter: filter,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to read logs: ${result.stderr || result.stdout}`);
  }

  async createSink(params) {
    // Parse: name DESTINATION dest FILTER "filter"
    const parsed = parseKeyValueParams(params);
    const parts = params.trim().split(/\s+/);
    const sinkName = parsed.name || parts[0];
    const destination = parsed.destination || parsed.dest;
    const filter = parsed.filter || '';

    if (!destination) {
      throw new Error('DESTINATION required for creating log sink');
    }

    const cmdParts = [
      'gcloud', 'logging', 'sinks', 'create', sinkName,
      destination,
      '--log-filter', filter
    ];

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      return {
        success: true,
        action: 'create_sink',
        sink: sinkName,
        destination: destination,
        filter: filter,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create log sink: ${result.stderr || result.stdout}`);
  }

  async createLogMetric(params) {
    // Parse: name FILTER "filter"
    const parsed = parseKeyValueParams(params);
    const parts = params.trim().split(/\s+/);
    const metricName = parsed.name || parts[0];
    const filter = parsed.filter || '';
    const description = parsed.description || 'Log-based metric';

    const cmdParts = [
      'gcloud', 'logging', 'metrics', 'create', metricName,
      '--log-filter', filter,
      '--description', description
    ];

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      return {
        success: true,
        action: 'create_log_metric',
        metric: metricName,
        filter: filter,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create log metric: ${result.stderr || result.stdout}`);
  }

  async listSinks() {
    const result = await this.executeGcloud([
      'gcloud', 'logging', 'sinks', 'list',
      '--format', 'json'
    ]);

    if (result.success) {
      let sinks = [];
      try {
        sinks = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        action: 'list_sinks',
        sinks: sinks,
        count: sinks.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list log sinks: ${result.stderr || result.stdout}`);
  }

  async deleteSink(params) {
    const parts = params.trim().split(/\s+/);
    const sinkName = parts[0];

    const result = await this.executeGcloud([
      'gcloud', 'logging', 'sinks', 'delete', sinkName,
      '--quiet'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'delete_sink',
        sink: sinkName,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to delete log sink: ${result.stderr || result.stdout}`);
  }

  async executeGcloud(cmdParts) {
    return new Promise((resolve) => {
      const process = spawn(cmdParts[0], cmdParts.slice(1), {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({
          success: code === 0,
          code,
          stdout: stdout.trim(),
          stderr: stderr.trim()
        });
      });

      process.on('error', (error) => {
        resolve({
          success: false,
          code: -1,
          stdout: '',
          stderr: error.message
        });
      });
    });
  }
}

// IAMHandler - extracted to gcp-handlers/iam-handler.js

// Placeholder for inline class definition (extracted)
  constructor(parent) {
    this.parent = parent;
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    if (upperCommand.startsWith('CREATE SERVICE-ACCOUNT ') || upperCommand.startsWith('CREATE SERVICEACCOUNT ')) {
      return await this.createServiceAccount(trimmed);
    }
    if (upperCommand.startsWith('DELETE SERVICE-ACCOUNT ') || upperCommand.startsWith('DELETE SERVICEACCOUNT ')) {
      return await this.deleteServiceAccount(trimmed);
    }
    if (upperCommand.startsWith('LIST SERVICE-ACCOUNTS') || upperCommand.startsWith('LIST SERVICEACCOUNTS')) {
      return await this.listServiceAccounts();
    }
    if (upperCommand.startsWith('GRANT ')) {
      return await this.grantRole(trimmed.substring(6).trim());
    }
    if (upperCommand.startsWith('REVOKE ')) {
      return await this.revokeRole(trimmed.substring(7).trim());
    }
    if (upperCommand.startsWith('CREATE KEY ')) {
      return await this.createKey(trimmed.substring(11).trim());
    }
    if (upperCommand.startsWith('LIST KEYS ')) {
      return await this.listKeys(trimmed.substring(10).trim());
    }
    if (upperCommand.startsWith('GET-POLICY') || upperCommand.startsWith('GET_POLICY')) {
      return await this.getPolicy(trimmed);
    }

    throw new Error(`Unknown IAM command: ${trimmed.split(' ')[0]}`);
  }

  async createServiceAccount(command) {
    // Parse: CREATE SERVICE-ACCOUNT name [display="Display Name"] [description="..."]
    const params = parseKeyValueParams(command);
    const parts = command.split(/\s+/);
    const accountName = params.name || parts[2] || parts[3]; // Skip CREATE and SERVICE-ACCOUNT
    const displayName = params.display || accountName;
    const description = params.description || 'Created by RexxJS';

    const cmdParts = [
      'gcloud', 'iam', 'service-accounts', 'create', accountName,
      '--display-name', displayName,
      '--description', description,
      '--format', 'json'
    ];

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      const project = this.parent.project;
      const email = `${accountName}@${project}.iam.gserviceaccount.com`;

      return {
        success: true,
        action: 'created',
        account: accountName,
        email: email,
        displayName: displayName,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create service account: ${result.stderr || result.stdout}`);
  }

  async deleteServiceAccount(command) {
    const params = parseKeyValueParams(command);
    const parts = command.split(/\s+/);
    const accountEmail = params.email || params.account || parts[2] || parts[3];

    const result = await this.executeGcloud([
      'gcloud', 'iam', 'service-accounts', 'delete', accountEmail,
      '--quiet'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'deleted',
        account: accountEmail,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to delete service account: ${result.stderr || result.stdout}`);
  }

  async listServiceAccounts() {
    const result = await this.executeGcloud([
      'gcloud', 'iam', 'service-accounts', 'list',
      '--format', 'json'
    ]);

    if (result.success) {
      let accounts = [];
      try {
        accounts = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        accounts: accounts,
        count: accounts.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list service accounts: ${result.stderr || result.stdout}`);
  }

  async grantRole(params) {
    // Parse: account role=roles/...
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const account = parsed.account || parsed.member || parts[0];
    const role = parsed.role;

    if (!role) {
      throw new Error('ROLE required. Usage: GRANT account@project.iam.gserviceaccount.com role=roles/viewer');
    }

    const member = account.includes('@') ? `serviceAccount:${account}` : account;
    const project = this.parent.project;

    const result = await this.executeGcloud([
      'gcloud', 'projects', 'add-iam-policy-binding', project,
      '--member', member,
      '--role', role,
      '--format', 'json'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'granted',
        member: account,
        role: role,
        project: project,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to grant role: ${result.stderr || result.stdout}`);
  }

  async revokeRole(params) {
    // Parse: account role=roles/...
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const account = parsed.account || parsed.member || parts[0];
    const role = parsed.role;

    if (!role) {
      throw new Error('ROLE required. Usage: REVOKE account@project.iam.gserviceaccount.com role=roles/viewer');
    }

    const member = account.includes('@') ? `serviceAccount:${account}` : account;
    const project = this.parent.project;

    const result = await this.executeGcloud([
      'gcloud', 'projects', 'remove-iam-policy-binding', project,
      '--member', member,
      '--role', role,
      '--format', 'json'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'revoked',
        member: account,
        role: role,
        project: project,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to revoke role: ${result.stderr || result.stdout}`);
  }

  async createKey(params) {
    // Parse: account [file=path/to/key.json]
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const account = parsed.account || parts[0];
    const keyFile = parsed.file || `${account.split('@')[0]}-key.json`;

    const result = await this.executeGcloud([
      'gcloud', 'iam', 'service-accounts', 'keys', 'create', keyFile,
      '--iam-account', account,
      '--key-file-type', 'json'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'created',
        account: account,
        keyFile: keyFile,
        warning: 'Store this key securely. It cannot be recovered if lost.',
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create key: ${result.stderr || result.stdout}`);
  }

  async listKeys(params) {
    const parts = params.split(/\s+/);
    const account = parts[0];

    const result = await this.executeGcloud([
      'gcloud', 'iam', 'service-accounts', 'keys', 'list',
      '--iam-account', account,
      '--format', 'json'
    ]);

    if (result.success) {
      let keys = [];
      try {
        keys = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        account: account,
        keys: keys,
        count: keys.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list keys: ${result.stderr || result.stdout}`);
  }

  async getPolicy(params) {
    const project = this.parent.project;

    const result = await this.executeGcloud([
      'gcloud', 'projects', 'get-iam-policy', project,
      '--format', 'json'
    ]);

    if (result.success) {
      let policy = null;
      try {
        policy = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        project: project,
        policy: policy,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to get IAM policy: ${result.stderr || result.stdout}`);
  }

  async executeGcloud(cmdParts) {
    return new Promise((resolve) => {
      const process = spawn(cmdParts[0], cmdParts.slice(1), {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({
          success: code === 0,
          code,
          stdout: stdout.trim(),
          stderr: stderr.trim()
        });
      });

      process.on('error', (error) => {
        resolve({
          success: false,
          code: -1,
          stdout: '',
          stderr: error.message
        });
      });
    });
  }
}

// CloudSQLHandler - extracted to gcp-handlers/cloud-sql-handler.js

// Placeholder for inline class definition (extracted)
  constructor(parent) {
    this.parent = parent;
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    if (upperCommand.startsWith('CREATE INSTANCE ') || upperCommand.startsWith('CREATE ')) {
      return await this.createInstance(trimmed);
    }
    if (upperCommand.startsWith('DELETE INSTANCE ') || upperCommand.startsWith('DELETE ')) {
      return await this.deleteInstance(trimmed);
    }
    if (upperCommand.startsWith('LIST') || upperCommand === '') {
      return await this.listInstances();
    }
    if (upperCommand.startsWith('DESCRIBE ') || upperCommand.startsWith('GET ')) {
      return await this.describeInstance(trimmed);
    }
    if (upperCommand.startsWith('CREATE DATABASE ')) {
      return await this.createDatabase(trimmed.substring(16).trim());
    }
    if (upperCommand.startsWith('CREATE USER ')) {
      return await this.createUser(trimmed.substring(12).trim());
    }
    if (upperCommand.startsWith('BACKUP ')) {
      return await this.createBackup(trimmed.substring(7).trim());
    }
    if (upperCommand.startsWith('LIST BACKUPS ')) {
      return await this.listBackups(trimmed.substring(13).trim());
    }

    throw new Error(`Unknown SQL command: ${trimmed.split(' ')[0]}`);
  }

  async createInstance(command) {
    // Parse: CREATE [INSTANCE] name [tier=db-f1-micro] [database=postgres|mysql] [version=...] [region=...]
    const params = parseKeyValueParams(command);
    const parts = command.split(/\s+/);
    let nameIdx = parts[0].toUpperCase() === 'CREATE' ? (parts[1].toUpperCase() === 'INSTANCE' ? 2 : 1) : 0;
    const instanceName = params.name || parts[nameIdx];

    const tier = params.tier || 'db-f1-micro';
    const database = params.database || params.db || 'postgres';
    const version = params.version || (database === 'mysql' ? 'MYSQL_8_0' : 'POSTGRES_15');
    const region = params.region || 'us-central1';

    const cmdParts = [
      'gcloud', 'sql', 'instances', 'create', instanceName,
      '--tier', tier,
      '--database-version', version,
      '--region', region,
      '--format', 'json'
    ];

    // Add optional parameters
    if (params.storage) {
      cmdParts.push('--storage-size', params.storage);
    }
    if (params.labels) {
      cmdParts.push('--labels', params.labels);
    }

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      let instanceData = null;
      try {
        const parsed = JSON.parse(result.stdout);
        instanceData = Array.isArray(parsed) ? parsed[0] : parsed;
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        action: 'created',
        instance: instanceName,
        tier: tier,
        version: version,
        region: region,
        data: instanceData,
        note: 'Cloud SQL instance creation takes several minutes',
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create Cloud SQL instance: ${result.stderr || result.stdout}`);
  }

  async deleteInstance(command) {
    const params = parseKeyValueParams(command);
    const parts = command.split(/\s+/);
    let nameIdx = parts[0].toUpperCase() === 'DELETE' ? (parts[1].toUpperCase() === 'INSTANCE' ? 2 : 1) : 0;
    const instanceName = params.instance || params.name || parts[nameIdx];

    const result = await this.executeGcloud([
      'gcloud', 'sql', 'instances', 'delete', instanceName,
      '--quiet'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'deleted',
        instance: instanceName,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to delete Cloud SQL instance: ${result.stderr || result.stdout}`);
  }

  async listInstances() {
    const result = await this.executeGcloud([
      'gcloud', 'sql', 'instances', 'list',
      '--format', 'json'
    ]);

    if (result.success) {
      let instances = [];
      try {
        instances = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        instances: instances,
        count: instances.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list Cloud SQL instances: ${result.stderr || result.stdout}`);
  }

  async describeInstance(command) {
    const params = parseKeyValueParams(command);
    const parts = command.split(/\s+/);
    const instanceName = params.instance || params.name || parts[1];

    const result = await this.executeGcloud([
      'gcloud', 'sql', 'instances', 'describe', instanceName,
      '--format', 'json'
    ]);

    if (result.success) {
      let instanceData = null;
      try {
        instanceData = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        instance: instanceName,
        data: instanceData,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to describe Cloud SQL instance: ${result.stderr || result.stdout}`);
  }

  async createDatabase(params) {
    // Parse: instance=name database=dbname
    const parsed = parseKeyValueParams(params);
    const instance = parsed.instance;
    const database = parsed.database || parsed.name;

    if (!instance || !database) {
      throw new Error('INSTANCE and DATABASE required. Usage: CREATE DATABASE instance=myinstance database=mydb');
    }

    const result = await this.executeGcloud([
      'gcloud', 'sql', 'databases', 'create', database,
      '--instance', instance
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'created',
        database: database,
        instance: instance,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create database: ${result.stderr || result.stdout}`);
  }

  async createUser(params) {
    // Parse: instance=name user=username password=...
    const parsed = parseKeyValueParams(params);
    const instance = parsed.instance;
    const user = parsed.user || parsed.name;
    const password = parsed.password;

    if (!instance || !user || !password) {
      throw new Error('INSTANCE, USER, and PASSWORD required. Usage: CREATE USER instance=myinstance user=myuser password=secret');
    }

    const result = await this.executeGcloud([
      'gcloud', 'sql', 'users', 'create', user,
      '--instance', instance,
      '--password', password
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'created',
        user: user,
        instance: instance,
        warning: 'Password is set. Store it securely.',
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create user: ${result.stderr || result.stdout}`);
  }

  async createBackup(params) {
    // Parse: instance=name [description="..."]
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const instance = parsed.instance || parts[0];
    const description = parsed.description || 'Manual backup from RexxJS';

    const result = await this.executeGcloud([
      'gcloud', 'sql', 'backups', 'create',
      '--instance', instance,
      '--description', description
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'created',
        instance: instance,
        description: description,
        note: 'Backup creation may take several minutes',
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create backup: ${result.stderr || result.stdout}`);
  }

  async listBackups(params) {
    const parts = params.split(/\s+/);
    const instance = parts[0];

    const result = await this.executeGcloud([
      'gcloud', 'sql', 'backups', 'list',
      '--instance', instance,
      '--format', 'json'
    ]);

    if (result.success) {
      let backups = [];
      try {
        backups = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        instance: instance,
        backups: backups,
        count: backups.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list backups: ${result.stderr || result.stdout}`);
  }

  async executeGcloud(cmdParts) {
    return new Promise((resolve) => {
      const process = spawn(cmdParts[0], cmdParts.slice(1), {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({
          success: code === 0,
          code,
          stdout: stdout.trim(),
          stderr: stderr.trim()
        });
      });

      process.on('error', (error) => {
        resolve({
          success: false,
          code: -1,
          stdout: '',
          stderr: error.message
        });
      });
    });
  }
}

// VPCHandler - extracted to gcp-handlers/vpc-handler.js

// Placeholder for inline class definition (extracted)
  constructor(parent) {
    this.parent = parent;
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    // Network operations
    if (upperCommand.startsWith('CREATE NETWORK ')) {
      return await this.createNetwork(trimmed.substring(15).trim());
    }
    if (upperCommand.startsWith('DELETE NETWORK ')) {
      return await this.deleteNetwork(trimmed.substring(15).trim());
    }
    if (upperCommand.startsWith('LIST NETWORKS') || upperCommand === 'LIST') {
      return await this.listNetworks();
    }

    // Subnet operations
    if (upperCommand.startsWith('CREATE SUBNET ')) {
      return await this.createSubnet(trimmed.substring(14).trim());
    }
    if (upperCommand.startsWith('DELETE SUBNET ')) {
      return await this.deleteSubnet(trimmed.substring(14).trim());
    }
    if (upperCommand.startsWith('LIST SUBNETS')) {
      return await this.listSubnets(trimmed);
    }

    // Firewall operations
    if (upperCommand.startsWith('CREATE FIREWALL ')) {
      return await this.createFirewall(trimmed.substring(16).trim());
    }
    if (upperCommand.startsWith('DELETE FIREWALL ')) {
      return await this.deleteFirewall(trimmed.substring(16).trim());
    }
    if (upperCommand.startsWith('LIST FIREWALLS') || upperCommand.startsWith('LIST FIREWALL')) {
      return await this.listFirewalls();
    }

    // Route operations
    if (upperCommand.startsWith('CREATE ROUTE ')) {
      return await this.createRoute(trimmed.substring(13).trim());
    }
    if (upperCommand.startsWith('LIST ROUTES')) {
      return await this.listRoutes();
    }

    throw new Error(`Unknown VPC command: ${trimmed.split(' ')[0]}`);
  }

  async createNetwork(params) {
    // Parse: name [subnet-mode=auto|custom] [description="..."]
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const networkName = parsed.name || parts[0];
    const subnetMode = parsed['subnet-mode'] || parsed.mode || 'auto';
    const description = parsed.description || 'Created by RexxJS';

    const cmdParts = [
      'gcloud', 'compute', 'networks', 'create', networkName,
      '--subnet-mode', subnetMode,
      '--description', description,
      '--format', 'json'
    ];

    // Add BGP routing mode if specified
    if (parsed.bgp || parsed['bgp-routing-mode']) {
      cmdParts.push('--bgp-routing-mode', parsed.bgp || parsed['bgp-routing-mode']);
    }

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      let networkData = null;
      try {
        const parsed = JSON.parse(result.stdout);
        networkData = Array.isArray(parsed) ? parsed[0] : parsed;
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        action: 'created',
        network: networkName,
        subnetMode: subnetMode,
        data: networkData,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create network: ${result.stderr || result.stdout}`);
  }

  async deleteNetwork(params) {
    const parts = params.split(/\s+/);
    const networkName = parts[0];

    const result = await this.executeGcloud([
      'gcloud', 'compute', 'networks', 'delete', networkName,
      '--quiet'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'deleted',
        network: networkName,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to delete network: ${result.stderr || result.stdout}`);
  }

  async listNetworks() {
    const result = await this.executeGcloud([
      'gcloud', 'compute', 'networks', 'list',
      '--format', 'json'
    ]);

    if (result.success) {
      let networks = [];
      try {
        networks = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        networks: networks,
        count: networks.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list networks: ${result.stderr || result.stdout}`);
  }

  async createSubnet(params) {
    // Parse: name network=network-name region=region range=CIDR
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const subnetName = parsed.name || parts[0];
    const network = parsed.network;
    const region = parsed.region || 'us-central1';
    const range = parsed.range || parsed.cidr;

    if (!network || !range) {
      throw new Error('NETWORK and RANGE required. Usage: CREATE SUBNET name network=mynet region=us-central1 range=10.0.0.0/24');
    }

    const cmdParts = [
      'gcloud', 'compute', 'networks', 'subnets', 'create', subnetName,
      '--network', network,
      '--region', region,
      '--range', range,
      '--format', 'json'
    ];

    // Add optional parameters
    if (parsed['private-google-access'] === 'true') {
      cmdParts.push('--enable-private-ip-google-access');
    }
    if (parsed['flow-logs'] === 'true') {
      cmdParts.push('--enable-flow-logs');
    }

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      let subnetData = null;
      try {
        const parsed = JSON.parse(result.stdout);
        subnetData = Array.isArray(parsed) ? parsed[0] : parsed;
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        action: 'created',
        subnet: subnetName,
        network: network,
        region: region,
        range: range,
        data: subnetData,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create subnet: ${result.stderr || result.stdout}`);
  }

  async deleteSubnet(params) {
    // Parse: name [region=us-central1]
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const subnetName = parsed.name || parts[0];
    const region = parsed.region || 'us-central1';

    const result = await this.executeGcloud([
      'gcloud', 'compute', 'networks', 'subnets', 'delete', subnetName,
      '--region', region,
      '--quiet'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'deleted',
        subnet: subnetName,
        region: region,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to delete subnet: ${result.stderr || result.stdout}`);
  }

  async listSubnets(params) {
    const parsed = parseKeyValueParams(params);
    const cmdParts = ['gcloud', 'compute', 'networks', 'subnets', 'list', '--format', 'json'];

    if (parsed.network) {
      cmdParts.push('--filter', `network:${parsed.network}`);
    }
    if (parsed.region) {
      cmdParts.push('--filter', `region:${parsed.region}`);
    }

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      let subnets = [];
      try {
        subnets = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        subnets: subnets,
        count: subnets.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list subnets: ${result.stderr || result.stdout}`);
  }

  async createFirewall(params) {
    // Parse: name network=net allow=tcp:80,tcp:443 [source-ranges=0.0.0.0/0] [target-tags=web]
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const firewallName = parsed.name || parts[0];
    const network = parsed.network || 'default';
    const allow = parsed.allow;
    const deny = parsed.deny;
    const sourceRanges = parsed['source-ranges'] || parsed.source || '0.0.0.0/0';
    const targetTags = parsed['target-tags'] || parsed.tags;

    if (!allow && !deny) {
      throw new Error('ALLOW or DENY required. Usage: CREATE FIREWALL name network=default allow=tcp:80,tcp:443');
    }

    const cmdParts = [
      'gcloud', 'compute', 'firewall-rules', 'create', firewallName,
      '--network', network,
      '--source-ranges', sourceRanges,
      '--format', 'json'
    ];

    if (allow) {
      cmdParts.push('--allow', allow);
    }
    if (deny) {
      cmdParts.push('--deny', deny);
    }
    if (targetTags) {
      cmdParts.push('--target-tags', targetTags);
    }
    if (parsed.description) {
      cmdParts.push('--description', parsed.description);
    }
    if (parsed.priority) {
      cmdParts.push('--priority', parsed.priority);
    }

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      let firewallData = null;
      try {
        const parsed = JSON.parse(result.stdout);
        firewallData = Array.isArray(parsed) ? parsed[0] : parsed;
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        action: 'created',
        firewall: firewallName,
        network: network,
        allow: allow,
        deny: deny,
        data: firewallData,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create firewall rule: ${result.stderr || result.stdout}`);
  }

  async deleteFirewall(params) {
    const parts = params.split(/\s+/);
    const firewallName = parts[0];

    const result = await this.executeGcloud([
      'gcloud', 'compute', 'firewall-rules', 'delete', firewallName,
      '--quiet'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'deleted',
        firewall: firewallName,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to delete firewall rule: ${result.stderr || result.stdout}`);
  }

  async listFirewalls() {
    const result = await this.executeGcloud([
      'gcloud', 'compute', 'firewall-rules', 'list',
      '--format', 'json'
    ]);

    if (result.success) {
      let firewalls = [];
      try {
        firewalls = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        firewalls: firewalls,
        count: firewalls.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list firewall rules: ${result.stderr || result.stdout}`);
  }

  async createRoute(params) {
    // Parse: name network=net dest=CIDR next-hop-gateway=default-internet-gateway
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const routeName = parsed.name || parts[0];
    const network = parsed.network || 'default';
    const destRange = parsed.dest || parsed['dest-range'];
    const nextHop = parsed['next-hop-gateway'] || parsed['next-hop-instance'] || parsed['next-hop-ip'];

    if (!destRange || !nextHop) {
      throw new Error('DEST and NEXT-HOP required. Usage: CREATE ROUTE name network=default dest=10.0.0.0/24 next-hop-gateway=default-internet-gateway');
    }

    const cmdParts = [
      'gcloud', 'compute', 'routes', 'create', routeName,
      '--network', network,
      '--destination-range', destRange,
      '--format', 'json'
    ];

    if (parsed['next-hop-gateway']) {
      cmdParts.push('--next-hop-gateway', parsed['next-hop-gateway']);
    } else if (parsed['next-hop-instance']) {
      cmdParts.push('--next-hop-instance', parsed['next-hop-instance']);
    } else if (parsed['next-hop-ip']) {
      cmdParts.push('--next-hop-address', parsed['next-hop-ip']);
    }

    if (parsed.priority) {
      cmdParts.push('--priority', parsed.priority);
    }

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      return {
        success: true,
        action: 'created',
        route: routeName,
        network: network,
        destRange: destRange,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create route: ${result.stderr || result.stdout}`);
  }

  async listRoutes() {
    const result = await this.executeGcloud([
      'gcloud', 'compute', 'routes', 'list',
      '--format', 'json'
    ]);

    if (result.success) {
      let routes = [];
      try {
        routes = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        routes: routes,
        count: routes.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list routes: ${result.stderr || result.stdout}`);
  }

  async executeGcloud(cmdParts) {
    return new Promise((resolve) => {
      const process = spawn(cmdParts[0], cmdParts.slice(1), {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({
          success: code === 0,
          code,
          stdout: stdout.trim(),
          stderr: stderr.trim()
        });
      });

      process.on('error', (error) => {
        resolve({
          success: false,
          code: -1,
          stdout: '',
          stderr: error.message
        });
      });
    });
  }
}

// ============================================
// DNS Handler
// ============================================

class DNSHandler {
  constructor(parent) {
    this.parent = parent;
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    // Managed zone operations
    if (upperCommand.startsWith('CREATE ZONE ')) {
      return await this.createZone(trimmed.substring(12).trim());
    }
    if (upperCommand.startsWith('DELETE ZONE ')) {
      return await this.deleteZone(trimmed.substring(12).trim());
    }
    if (upperCommand.startsWith('LIST ZONES') || upperCommand === 'LIST') {
      return await this.listZones();
    }

    // Record operations
    if (upperCommand.startsWith('ADD-RECORD ') || upperCommand.startsWith('ADD RECORD ')) {
      return await this.addRecord(trimmed);
    }
    if (upperCommand.startsWith('DELETE-RECORD ') || upperCommand.startsWith('DELETE RECORD ')) {
      return await this.deleteRecord(trimmed);
    }
    if (upperCommand.startsWith('LIST RECORDS ')) {
      return await this.listRecords(trimmed.substring(13).trim());
    }

    throw new Error(`Unknown DNS command: ${trimmed.split(' ')[0]}`);
  }

  async createZone(params) {
    // Parse: name domain=example.com [description="..."]
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const zoneName = parsed.name || parts[0];
    const domain = parsed.domain || parsed.dns;
    const description = parsed.description || `DNS zone for ${domain}`;

    if (!domain) {
      throw new Error('DOMAIN required. Usage: CREATE ZONE name domain=example.com');
    }

    const cmdParts = [
      'gcloud', 'dns', 'managed-zones', 'create', zoneName,
      '--dns-name', domain,
      '--description', description,
      '--format', 'json'
    ];

    // Add DNSSEC if requested
    if (parsed.dnssec === 'true') {
      cmdParts.push('--dnssec-state', 'on');
    }

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      let zoneData = null;
      try {
        zoneData = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        action: 'created',
        zone: zoneName,
        domain: domain,
        data: zoneData,
        note: 'Update your domain registrar with the nameservers shown in the zone data',
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create DNS zone: ${result.stderr || result.stdout}`);
  }

  async deleteZone(params) {
    const parts = params.split(/\s+/);
    const zoneName = parts[0];

    const result = await this.executeGcloud([
      'gcloud', 'dns', 'managed-zones', 'delete', zoneName,
      '--quiet'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'deleted',
        zone: zoneName,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to delete DNS zone: ${result.stderr || result.stdout}`);
  }

  async listZones() {
    const result = await this.executeGcloud([
      'gcloud', 'dns', 'managed-zones', 'list',
      '--format', 'json'
    ]);

    if (result.success) {
      let zones = [];
      try {
        zones = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        zones: zones,
        count: zones.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list DNS zones: ${result.stderr || result.stdout}`);
  }

  async addRecord(command) {
    // Parse: ADD-RECORD zone name=www type=A ttl=300 data=1.2.3.4
    const params = command.substring(command.toUpperCase().indexOf('RECORD') + 6).trim();
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const zoneName = parsed.zone || parts[0];
    const recordName = parsed.name;
    const recordType = parsed.type || 'A';
    const ttl = parsed.ttl || '300';
    const data = parsed.data || parsed.value;

    if (!zoneName || !recordName || !data) {
      throw new Error('ZONE, NAME, and DATA required. Usage: ADD-RECORD zone name=www type=A ttl=300 data=1.2.3.4');
    }

    const cmdParts = [
      'gcloud', 'dns', 'record-sets', 'create', recordName,
      '--zone', zoneName,
      '--type', recordType,
      '--ttl', ttl,
      '--rrdatas', data
    ];

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      return {
        success: true,
        action: 'created',
        zone: zoneName,
        record: recordName,
        type: recordType,
        ttl: ttl,
        data: data,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to add DNS record: ${result.stderr || result.stdout}`);
  }

  async deleteRecord(command) {
    // Parse: DELETE-RECORD zone name=www type=A
    const params = command.substring(command.toUpperCase().indexOf('RECORD') + 6).trim();
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const zoneName = parsed.zone || parts[0];
    const recordName = parsed.name;
    const recordType = parsed.type || 'A';

    if (!zoneName || !recordName) {
      throw new Error('ZONE and NAME required. Usage: DELETE-RECORD zone name=www type=A');
    }

    const result = await this.executeGcloud([
      'gcloud', 'dns', 'record-sets', 'delete', recordName,
      '--zone', zoneName,
      '--type', recordType,
      '--quiet'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'deleted',
        zone: zoneName,
        record: recordName,
        type: recordType,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to delete DNS record: ${result.stderr || result.stdout}`);
  }

  async listRecords(params) {
    const parts = params.split(/\s+/);
    const zoneName = parts[0];

    const result = await this.executeGcloud([
      'gcloud', 'dns', 'record-sets', 'list',
      '--zone', zoneName,
      '--format', 'json'
    ]);

    if (result.success) {
      let records = [];
      try {
        records = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        zone: zoneName,
        records: records,
        count: records.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list DNS records: ${result.stderr || result.stdout}`);
  }

  async executeGcloud(cmdParts) {
    return new Promise((resolve) => {
      const process = spawn(cmdParts[0], cmdParts.slice(1), {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({
          success: code === 0,
          code,
          stdout: stdout.trim(),
          stderr: stderr.trim()
        });
      });

      process.on('error', (error) => {
        resolve({
          success: false,
          code: -1,
          stdout: '',
          stderr: error.message
        });
      });
    });
  }
}

// ============================================
// Secret Manager Handler
// ============================================

class SecretManagerHandler {
  constructor(parent) {
    this.parent = parent;
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    // Secret operations
    if (upperCommand.startsWith('CREATE ')) {
      return await this.createSecret(trimmed.substring(7).trim());
    }
    if (upperCommand.startsWith('DELETE ')) {
      return await this.deleteSecret(trimmed.substring(7).trim());
    }
    if (upperCommand.startsWith('LIST') || upperCommand === '') {
      return await this.listSecrets();
    }

    // Version operations
    if (upperCommand.startsWith('ADD-VERSION ') || upperCommand.startsWith('ADD VERSION ')) {
      return await this.addVersion(trimmed);
    }
    if (upperCommand.startsWith('ACCESS ')) {
      return await this.accessSecret(trimmed.substring(7).trim());
    }
    if (upperCommand.startsWith('LIST VERSIONS ')) {
      return await this.listVersions(trimmed.substring(14).trim());
    }
    if (upperCommand.startsWith('DESTROY VERSION ')) {
      return await this.destroyVersion(trimmed.substring(16).trim());
    }

    throw new Error(`Unknown SECRET command: ${trimmed.split(' ')[0]}`);
  }

  async createSecret(params) {
    // Parse: name [replication=automatic] [labels=env=prod]
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const secretName = parsed.name || parts[0];
    const replication = parsed.replication || 'automatic';

    const cmdParts = [
      'gcloud', 'secrets', 'create', secretName,
      '--replication-policy', replication
    ];

    if (parsed.labels) {
      cmdParts.push('--labels', parsed.labels);
    }

    const result = await this.executeGcloud(cmdParts);

    if (result.success) {
      return {
        success: true,
        action: 'created',
        secret: secretName,
        replication: replication,
        note: 'Secret created. Add a version with ADD-VERSION to store actual secret data.',
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to create secret: ${result.stderr || result.stdout}`);
  }

  async deleteSecret(params) {
    const parts = params.split(/\s+/);
    const secretName = parts[0];

    const result = await this.executeGcloud([
      'gcloud', 'secrets', 'delete', secretName,
      '--quiet'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'deleted',
        secret: secretName,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to delete secret: ${result.stderr || result.stdout}`);
  }

  async listSecrets() {
    const result = await this.executeGcloud([
      'gcloud', 'secrets', 'list',
      '--format', 'json'
    ]);

    if (result.success) {
      let secrets = [];
      try {
        secrets = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        secrets: secrets,
        count: secrets.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list secrets: ${result.stderr || result.stdout}`);
  }

  async addVersion(command) {
    // Parse: ADD-VERSION secret data="secret-value" or data-file=path
    const params = command.substring(command.toUpperCase().indexOf('VERSION') + 7).trim();
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const secretName = parsed.secret || parts[0];
    const data = parsed.data;
    const dataFile = parsed['data-file'] || parsed.file;

    if (!secretName || (!data && !dataFile)) {
      throw new Error('SECRET and (DATA or DATA-FILE) required. Usage: ADD-VERSION secret data="my-secret-value"');
    }

    const cmdParts = ['gcloud', 'secrets', 'versions', 'add', secretName];

    if (data) {
      // Pass data via stdin using echo
      const result = await this.executeGcloudWithInput(cmdParts.concat('--data-file', '-'), data);

      if (result.success) {
        return {
          success: true,
          action: 'version_added',
          secret: secretName,
          note: 'New version created with provided data',
          stdout: result.stdout,
          stderr: result.stderr
        };
      }

      throw new Error(`Failed to add secret version: ${result.stderr || result.stdout}`);
    } else {
      // Use data from file
      cmdParts.push('--data-file', dataFile);

      const result = await this.executeGcloud(cmdParts);

      if (result.success) {
        return {
          success: true,
          action: 'version_added',
          secret: secretName,
          dataFile: dataFile,
          stdout: result.stdout,
          stderr: result.stderr
        };
      }

      throw new Error(`Failed to add secret version from file: ${result.stderr || result.stdout}`);
    }
  }

  async accessSecret(params) {
    // Parse: secret [version=latest]
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const secretName = parsed.secret || parts[0];
    const version = parsed.version || 'latest';

    const result = await this.executeGcloud([
      'gcloud', 'secrets', 'versions', 'access', version,
      '--secret', secretName
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'accessed',
        secret: secretName,
        version: version,
        value: result.stdout,
        warning: 'Secret value exposed in stdout - handle securely',
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to access secret: ${result.stderr || result.stdout}`);
  }

  async listVersions(params) {
    const parts = params.split(/\s+/);
    const secretName = parts[0];

    const result = await this.executeGcloud([
      'gcloud', 'secrets', 'versions', 'list', secretName,
      '--format', 'json'
    ]);

    if (result.success) {
      let versions = [];
      try {
        versions = JSON.parse(result.stdout);
      } catch (e) {
        // JSON parsing failed
      }

      return {
        success: true,
        secret: secretName,
        versions: versions,
        count: versions.length,
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to list secret versions: ${result.stderr || result.stdout}`);
  }

  async destroyVersion(params) {
    // Parse: secret version=1
    const parsed = parseKeyValueParams(params);
    const parts = params.split(/\s+/);
    const secretName = parsed.secret || parts[0];
    const version = parsed.version;

    if (!version) {
      throw new Error('VERSION required. Usage: DESTROY VERSION secret version=1');
    }

    const result = await this.executeGcloud([
      'gcloud', 'secrets', 'versions', 'destroy', version,
      '--secret', secretName,
      '--quiet'
    ]);

    if (result.success) {
      return {
        success: true,
        action: 'destroyed',
        secret: secretName,
        version: version,
        note: 'Version destroyed - data is permanently deleted',
        stdout: result.stdout,
        stderr: result.stderr
      };
    }

    throw new Error(`Failed to destroy secret version: ${result.stderr || result.stdout}`);
  }

  async executeGcloud(cmdParts) {
    return new Promise((resolve) => {
      const process = spawn(cmdParts[0], cmdParts.slice(1), {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        resolve({
          success: code === 0,
          code,
          stdout: stdout.trim(),
          stderr: stderr.trim()
        });
      });

      process.on('error', (error) => {
        resolve({
          success: false,
          code: -1,
          stdout: '',
          stderr: error.message
        });
      });
    });
  }

  async executeGcloudWithInput(cmdParts, input) {
    return new Promise((resolve) => {
      const process = spawn(cmdParts[0], cmdParts.slice(1), {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      process.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      // Write input to stdin
      process.stdin.write(input);
      process.stdin.end();

      process.on('close', (code) => {
        resolve({
          success: code === 0,
          code,
          stdout: stdout.trim(),
          stderr: stderr.trim()
        });
      });

      process.on('error', (error) => {
        resolve({
          success: false,
          code: -1,
          stdout: '',
          stderr: error.message
        });
      });
    });
  }
}

// CloudKMSHandler - extracted to gcp-handlers/cloud-kms-handler.js

// ============================================
// Cloud Tasks Handler
// ============================================

class CloudTasksHandler {
  constructor(parent) {
    this.parent = parent;
  }

  async initialize() {
    // Tasks operations work via gcloud CLI
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    // CREATE QUEUE name=... [location=...]
    if (upperCommand.startsWith('CREATE QUEUE ')) {
      return await this.createQueue(trimmed.substring(13));
    }

    // DELETE QUEUE name=... [location=...]
    if (upperCommand.startsWith('DELETE QUEUE ')) {
      return await this.deleteQueue(trimmed.substring(13));
    }

    // LIST QUEUES [location=...]
    if (upperCommand.startsWith('LIST QUEUES')) {
      return await this.listQueues(trimmed.substring(11).trim());
    }

    // CREATE TASK queue=... [payload=...] [schedule-time=...] [location=...]
    if (upperCommand.startsWith('CREATE TASK ')) {
      return await this.createTask(trimmed.substring(12));
    }

    // LIST TASKS queue=... [location=...]
    if (upperCommand.startsWith('LIST TASKS ')) {
      return await this.listTasks(trimmed.substring(11));
    }

    // DESCRIBE QUEUE name=... [location=...]
    if (upperCommand.startsWith('DESCRIBE QUEUE ')) {
      return await this.describeQueue(trimmed.substring(15));
    }

    // PAUSE QUEUE name=... [location=...]
    if (upperCommand.startsWith('PAUSE QUEUE ')) {
      return await this.pauseQueue(trimmed.substring(12));
    }

    // RESUME QUEUE name=... [location=...]
    if (upperCommand.startsWith('RESUME QUEUE ')) {
      return await this.resumeQueue(trimmed.substring(13));
    }

    // INFO
    if (upperCommand === 'INFO') {
      return this.getInfo();
    }

    throw new Error(`Unknown TASKS command: ${trimmed.split(' ')[0]}`);
  }

  async createQueue(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Queue name required: CREATE QUEUE name=... location=...');
    }

    const result = await this.executeGcloud([
      'tasks', 'queues', 'create', name,
      '--location', location,
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'create_queue',
      queue: name,
      location: location,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async deleteQueue(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Queue name required: DELETE QUEUE name=... location=...');
    }

    const result = await this.executeGcloud([
      'tasks', 'queues', 'delete', name,
      '--location', location,
      '--quiet',
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'delete_queue',
      queue: name,
      location: location,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async listQueues(command) {
    const params = parseKeyValueParams(command);
    const location = params.location || 'us-central1';

    const result = await this.executeGcloud([
      'tasks', 'queues', 'list',
      '--location', location,
      '--format', 'json'
    ]);

    let queues = [];
    if (result.success && result.stdout) {
      try {
        queues = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'list_queues',
      location: location,
      queues: queues,
      count: queues.length || 0,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async createTask(command) {
    const params = parseKeyValueParams(command);
    const queue = params.queue;
    const location = params.location || 'us-central1';
    const url = params.url; // HTTP target URL
    const payload = params.payload; // Task payload (JSON string or text)
    const scheduleTime = params['schedule-time']; // ISO 8601 format

    if (!queue) {
      throw new Error('Queue required: CREATE TASK queue=... url=... [payload=...] [schedule-time=...]');
    }

    const args = [
      'tasks', 'create-http-task',
      '--queue', queue,
      '--location', location,
      '--format', 'json'
    ];

    if (url) {
      args.push('--url', url);
    }

    if (payload) {
      args.push('--body-content', payload);
    }

    if (scheduleTime) {
      args.push('--schedule-time', scheduleTime);
    }

    const result = await this.executeGcloud(args);

    return {
      success: result.success,
      action: 'create_task',
      queue: queue,
      location: location,
      url: url,
      scheduled: scheduleTime || 'immediate',
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async listTasks(command) {
    const params = parseKeyValueParams(command);
    const queue = params.queue;
    const location = params.location || 'us-central1';

    if (!queue) {
      throw new Error('Queue required: LIST TASKS queue=... location=...');
    }

    const result = await this.executeGcloud([
      'tasks', 'list',
      '--queue', queue,
      '--location', location,
      '--format', 'json'
    ]);

    let tasks = [];
    if (result.success && result.stdout) {
      try {
        tasks = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'list_tasks',
      queue: queue,
      location: location,
      tasks: tasks,
      count: tasks.length || 0,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async describeQueue(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Queue name required: DESCRIBE QUEUE name=... location=...');
    }

    const result = await this.executeGcloud([
      'tasks', 'queues', 'describe', name,
      '--location', location,
      '--format', 'json'
    ]);

    let queueData = null;
    if (result.success && result.stdout) {
      try {
        queueData = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'describe_queue',
      queue: name,
      location: location,
      data: queueData,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async pauseQueue(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Queue name required: PAUSE QUEUE name=... location=...');
    }

    const result = await this.executeGcloud([
      'tasks', 'queues', 'pause', name,
      '--location', location,
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'pause_queue',
      queue: name,
      location: location,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async resumeQueue(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Queue name required: RESUME QUEUE name=... location=...');
    }

    const result = await this.executeGcloud([
      'tasks', 'queues', 'resume', name,
      '--location', location,
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'resume_queue',
      queue: name,
      location: location,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  getInfo() {
    return {
      success: true,
      service: 'Cloud Tasks',
      description: 'Asynchronous task execution service',
      capabilities: [
        'CREATE QUEUE - Create a task queue',
        'DELETE QUEUE - Delete a task queue',
        'LIST QUEUES - List all task queues',
        'CREATE TASK - Create an HTTP task',
        'LIST TASKS - List tasks in a queue',
        'DESCRIBE QUEUE - Get queue details',
        'PAUSE QUEUE - Pause task execution',
        'RESUME QUEUE - Resume task execution'
      ],
      examples: {
        'Create queue': 'TASKS CREATE QUEUE name=my-queue location=us-central1',
        'Create task': 'TASKS CREATE TASK queue=my-queue url=https://example.com/handler payload="{\\"data\\":\\"value\\"}"',
        'List tasks': 'TASKS LIST TASKS queue=my-queue',
        'Pause queue': 'TASKS PAUSE QUEUE name=my-queue'
      }
    };
  }

  async executeGcloud(args) {
    return await this.parent.execCommand('gcloud', args);
  }
}

// ============================================
// Cloud Scheduler Handler
// ============================================

class CloudSchedulerHandler {
  constructor(parent) {
    this.parent = parent;
  }

  async initialize() {
    // Scheduler operations work via gcloud CLI
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    // CREATE JOB name=... schedule=... [location=...] [target=...] [uri=...]
    if (upperCommand.startsWith('CREATE JOB ')) {
      return await this.createJob(trimmed.substring(11));
    }

    // DELETE JOB name=... [location=...]
    if (upperCommand.startsWith('DELETE JOB ')) {
      return await this.deleteJob(trimmed.substring(11));
    }

    // LIST JOBS [location=...]
    if (upperCommand.startsWith('LIST JOBS')) {
      return await this.listJobs(trimmed.substring(9).trim());
    }

    // RUN JOB name=... [location=...]
    if (upperCommand.startsWith('RUN JOB ')) {
      return await this.runJob(trimmed.substring(8));
    }

    // PAUSE JOB name=... [location=...]
    if (upperCommand.startsWith('PAUSE JOB ')) {
      return await this.pauseJob(trimmed.substring(10));
    }

    // RESUME JOB name=... [location=...]
    if (upperCommand.startsWith('RESUME JOB ')) {
      return await this.resumeJob(trimmed.substring(11));
    }

    // DESCRIBE JOB name=... [location=...]
    if (upperCommand.startsWith('DESCRIBE JOB ')) {
      return await this.describeJob(trimmed.substring(13));
    }

    // INFO
    if (upperCommand === 'INFO') {
      return this.getInfo();
    }

    throw new Error(`Unknown SCHEDULER command: ${trimmed.split(' ')[0]}`);
  }

  async createJob(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const schedule = params.schedule; // Cron format: "0 */2 * * *"
    const location = params.location || 'us-central1';
    const uri = params.uri; // HTTP target
    const topic = params.topic; // Pub/Sub topic
    const messageBody = params['message-body'];

    if (!name || !schedule) {
      throw new Error('Job name and schedule required: CREATE JOB name=... schedule=... [uri=...] [topic=...]');
    }

    let args = [
      'scheduler', 'jobs', 'create'
    ];

    // Determine target type
    if (uri) {
      args.push('http', name);
      args.push('--schedule', schedule);
      args.push('--uri', uri);
      args.push('--location', location);
      if (messageBody) {
        args.push('--message-body', messageBody);
      }
    } else if (topic) {
      args.push('pubsub', name);
      args.push('--schedule', schedule);
      args.push('--topic', topic);
      args.push('--location', location);
      if (messageBody) {
        args.push('--message-body', messageBody);
      }
    } else {
      throw new Error('Either uri= or topic= must be specified for job target');
    }

    args.push('--format', 'json');

    const result = await this.executeGcloud(args);

    return {
      success: result.success,
      action: 'create_job',
      job: name,
      schedule: schedule,
      location: location,
      target: uri || topic,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async deleteJob(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Job name required: DELETE JOB name=... location=...');
    }

    const result = await this.executeGcloud([
      'scheduler', 'jobs', 'delete', name,
      '--location', location,
      '--quiet',
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'delete_job',
      job: name,
      location: location,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async listJobs(command) {
    const params = parseKeyValueParams(command);
    const location = params.location || 'us-central1';

    const result = await this.executeGcloud([
      'scheduler', 'jobs', 'list',
      '--location', location,
      '--format', 'json'
    ]);

    let jobs = [];
    if (result.success && result.stdout) {
      try {
        jobs = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'list_jobs',
      location: location,
      jobs: jobs,
      count: jobs.length || 0,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async runJob(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Job name required: RUN JOB name=... location=...');
    }

    const result = await this.executeGcloud([
      'scheduler', 'jobs', 'run', name,
      '--location', location,
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'run_job',
      job: name,
      location: location,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async pauseJob(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Job name required: PAUSE JOB name=... location=...');
    }

    const result = await this.executeGcloud([
      'scheduler', 'jobs', 'pause', name,
      '--location', location,
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'pause_job',
      job: name,
      location: location,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async resumeJob(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Job name required: RESUME JOB name=... location=...');
    }

    const result = await this.executeGcloud([
      'scheduler', 'jobs', 'resume', name,
      '--location', location,
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'resume_job',
      job: name,
      location: location,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async describeJob(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Job name required: DESCRIBE JOB name=... location=...');
    }

    const result = await this.executeGcloud([
      'scheduler', 'jobs', 'describe', name,
      '--location', location,
      '--format', 'json'
    ]);

    let jobData = null;
    if (result.success && result.stdout) {
      try {
        jobData = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'describe_job',
      job: name,
      location: location,
      data: jobData,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  getInfo() {
    return {
      success: true,
      service: 'Cloud Scheduler',
      description: 'Fully managed cron job service',
      capabilities: [
        'CREATE JOB - Create a scheduled job',
        'DELETE JOB - Delete a scheduled job',
        'LIST JOBS - List all scheduled jobs',
        'RUN JOB - Manually trigger a job',
        'PAUSE JOB - Pause job execution',
        'RESUME JOB - Resume job execution',
        'DESCRIBE JOB - Get job details'
      ],
      examples: {
        'Create HTTP job': 'SCHEDULER CREATE JOB name=hourly-task schedule="0 * * * *" uri=https://example.com/task',
        'Create Pub/Sub job': 'SCHEDULER CREATE JOB name=daily-job schedule="0 0 * * *" topic=my-topic message-body="daily run"',
        'Run job now': 'SCHEDULER RUN JOB name=hourly-task',
        'Pause job': 'SCHEDULER PAUSE JOB name=hourly-task'
      },
      cron_format: {
        description: 'Schedule uses Unix cron format: minute hour day month weekday',
        examples: {
          'Every hour': '0 * * * *',
          'Every day at midnight': '0 0 * * *',
          'Every Monday at 9am': '0 9 * * 1',
          'Every 15 minutes': '*/15 * * * *',
          'First day of month': '0 0 1 * *'
        }
      }
    };
  }

  async executeGcloud(args) {
    return await this.parent.execCommand('gcloud', args);
  }
}

// ============================================
// Artifact Registry Handler
// ============================================

class ArtifactRegistryHandler {
  constructor(parent) {
    this.parent = parent;
  }

  async initialize() {
    // Artifact Registry operations work via gcloud CLI
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    // CREATE REPOSITORY name=... location=... format=...
    if (upperCommand.startsWith('CREATE REPOSITORY ')) {
      return await this.createRepository(trimmed.substring(18));
    }

    // DELETE REPOSITORY name=... location=...
    if (upperCommand.startsWith('DELETE REPOSITORY ')) {
      return await this.deleteRepository(trimmed.substring(18));
    }

    // LIST REPOSITORIES [location=...]
    if (upperCommand.startsWith('LIST REPOSITORIES')) {
      return await this.listRepositories(trimmed.substring(17).trim());
    }

    // LIST IMAGES repository=... [location=...]
    if (upperCommand.startsWith('LIST IMAGES ')) {
      return await this.listImages(trimmed.substring(12));
    }

    // LIST TAGS repository=... image=... [location=...]
    if (upperCommand.startsWith('LIST TAGS ')) {
      return await this.listTags(trimmed.substring(10));
    }

    // DELETE IMAGE repository=... image=... [location=...]
    if (upperCommand.startsWith('DELETE IMAGE ')) {
      return await this.deleteImage(trimmed.substring(13));
    }

    // DESCRIBE REPOSITORY name=... [location=...]
    if (upperCommand.startsWith('DESCRIBE REPOSITORY ')) {
      return await this.describeRepository(trimmed.substring(20));
    }

    // INFO
    if (upperCommand === 'INFO') {
      return this.getInfo();
    }

    throw new Error(`Unknown ARTIFACT-REGISTRY command: ${trimmed.split(' ')[0]}`);
  }

  async createRepository(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';
    const format = params.format || 'docker'; // docker, maven, npm, python, apt, yum

    if (!name) {
      throw new Error('Repository name required: CREATE REPOSITORY name=... location=... format=...');
    }

    const result = await this.executeGcloud([
      'artifacts', 'repositories', 'create', name,
      '--repository-format', format,
      '--location', location,
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'create_repository',
      repository: name,
      location: location,
      format: format,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async deleteRepository(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Repository name required: DELETE REPOSITORY name=... location=...');
    }

    const result = await this.executeGcloud([
      'artifacts', 'repositories', 'delete', name,
      '--location', location,
      '--quiet',
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'delete_repository',
      repository: name,
      location: location,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async listRepositories(command) {
    const params = parseKeyValueParams(command);
    const location = params.location || 'us-central1';

    const result = await this.executeGcloud([
      'artifacts', 'repositories', 'list',
      '--location', location,
      '--format', 'json'
    ]);

    let repositories = [];
    if (result.success && result.stdout) {
      try {
        repositories = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'list_repositories',
      location: location,
      repositories: repositories,
      count: repositories.length || 0,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async listImages(command) {
    const params = parseKeyValueParams(command);
    const repository = params.repository;
    const location = params.location || 'us-central1';

    if (!repository) {
      throw new Error('Repository required: LIST IMAGES repository=... location=...');
    }

    const result = await this.executeGcloud([
      'artifacts', 'docker', 'images', 'list',
      `${location}-docker.pkg.dev/${this.parent.project}/${repository}`,
      '--format', 'json'
    ]);

    let images = [];
    if (result.success && result.stdout) {
      try {
        images = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'list_images',
      repository: repository,
      location: location,
      images: images,
      count: images.length || 0,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async listTags(command) {
    const params = parseKeyValueParams(command);
    const repository = params.repository;
    const image = params.image;
    const location = params.location || 'us-central1';

    if (!repository || !image) {
      throw new Error('Repository and image required: LIST TAGS repository=... image=... location=...');
    }

    const result = await this.executeGcloud([
      'artifacts', 'docker', 'tags', 'list',
      `${location}-docker.pkg.dev/${this.parent.project}/${repository}/${image}`,
      '--format', 'json'
    ]);

    let tags = [];
    if (result.success && result.stdout) {
      try {
        tags = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'list_tags',
      repository: repository,
      image: image,
      location: location,
      tags: tags,
      count: tags.length || 0,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async deleteImage(command) {
    const params = parseKeyValueParams(command);
    const repository = params.repository;
    const image = params.image;
    const tag = params.tag || 'latest';
    const location = params.location || 'us-central1';

    if (!repository || !image) {
      throw new Error('Repository and image required: DELETE IMAGE repository=... image=... [tag=...] location=...');
    }

    const imageUri = `${location}-docker.pkg.dev/${this.parent.project}/${repository}/${image}:${tag}`;

    const result = await this.executeGcloud([
      'artifacts', 'docker', 'images', 'delete',
      imageUri,
      '--quiet',
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'delete_image',
      repository: repository,
      image: image,
      tag: tag,
      location: location,
      imageUri: imageUri,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async describeRepository(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const location = params.location || 'us-central1';

    if (!name) {
      throw new Error('Repository name required: DESCRIBE REPOSITORY name=... location=...');
    }

    const result = await this.executeGcloud([
      'artifacts', 'repositories', 'describe', name,
      '--location', location,
      '--format', 'json'
    ]);

    let repoData = null;
    if (result.success && result.stdout) {
      try {
        repoData = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'describe_repository',
      repository: name,
      location: location,
      data: repoData,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  getInfo() {
    return {
      success: true,
      service: 'Artifact Registry',
      description: 'Manage container images and language packages',
      capabilities: [
        'CREATE REPOSITORY - Create an artifact repository',
        'DELETE REPOSITORY - Delete a repository',
        'LIST REPOSITORIES - List repositories',
        'LIST IMAGES - List container images',
        'LIST TAGS - List image tags',
        'DELETE IMAGE - Delete a container image',
        'DESCRIBE REPOSITORY - Get repository details'
      ],
      examples: {
        'Create Docker repository': 'ARTIFACT-REGISTRY CREATE REPOSITORY name=my-repo format=docker location=us-central1',
        'List images': 'ARTIFACT-REGISTRY LIST IMAGES repository=my-repo',
        'Delete image': 'ARTIFACT-REGISTRY DELETE IMAGE repository=my-repo image=myapp tag=v1.0.0'
      },
      formats: {
        docker: 'Docker container images',
        maven: 'Maven packages',
        npm: 'npm packages',
        python: 'Python packages',
        apt: 'Debian packages',
        yum: 'RPM packages'
      }
    };
  }

  async executeGcloud(args) {
    return await this.parent.execCommand('gcloud', args);
  }
}

// GKEHandler - extracted to gcp-handlers/gke-handler.js

// Placeholder for inline class definition (extracted)
  constructor(parent) {
    this.parent = parent;
  }

  async initialize() {
    // GKE operations work via gcloud CLI
  }

  async handle(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    // CREATE CLUSTER name=... [zone=...] [num-nodes=...]
    if (upperCommand.startsWith('CREATE CLUSTER ')) {
      return await this.createCluster(trimmed.substring(15));
    }

    // DELETE CLUSTER name=... [zone=...]
    if (upperCommand.startsWith('DELETE CLUSTER ')) {
      return await this.deleteCluster(trimmed.substring(15));
    }

    // LIST CLUSTERS [zone=...]
    if (upperCommand.startsWith('LIST CLUSTERS')) {
      return await this.listClusters(trimmed.substring(13).trim());
    }

    // DESCRIBE CLUSTER name=... [zone=...]
    if (upperCommand.startsWith('DESCRIBE CLUSTER ')) {
      return await this.describeCluster(trimmed.substring(17));
    }

    // GET CREDENTIALS name=... [zone=...]
    if (upperCommand.startsWith('GET CREDENTIALS ') || upperCommand.startsWith('GET-CREDENTIALS ')) {
      const startPos = upperCommand.startsWith('GET CREDENTIALS ') ? 16 : 16;
      return await this.getCredentials(trimmed.substring(startPos));
    }

    // RESIZE CLUSTER name=... num-nodes=... [zone=...]
    if (upperCommand.startsWith('RESIZE CLUSTER ')) {
      return await this.resizeCluster(trimmed.substring(15));
    }

    // UPGRADE CLUSTER name=... [zone=...] [version=...]
    if (upperCommand.startsWith('UPGRADE CLUSTER ')) {
      return await this.upgradeCluster(trimmed.substring(16));
    }

    // LIST NODE-POOLS cluster=... [zone=...]
    if (upperCommand.startsWith('LIST NODE-POOLS ') || upperCommand.startsWith('LIST NODEPOOLS ')) {
      return await this.listNodePools(trimmed.substring(16));
    }

    // INFO
    if (upperCommand === 'INFO') {
      return this.getInfo();
    }

    throw new Error(`Unknown GKE command: ${trimmed.split(' ')[0]}`);
  }

  async createCluster(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const zone = params.zone || 'us-central1-a';
    const numNodes = params['num-nodes'] || '3';
    const machineType = params['machine-type'] || 'e2-medium';
    const diskSize = params['disk-size'] || '100';

    if (!name) {
      throw new Error('Cluster name required: CREATE CLUSTER name=... zone=... num-nodes=...');
    }

    const args = [
      'container', 'clusters', 'create', name,
      '--zone', zone,
      '--num-nodes', numNodes,
      '--machine-type', machineType,
      '--disk-size', diskSize,
      '--format', 'json'
    ];

    // Add optional autopilot mode
    if (params.autopilot === 'true') {
      args.push('--enable-autopilot');
    }

    const result = await this.executeGcloud(args);

    return {
      success: result.success,
      action: 'create_cluster',
      cluster: name,
      zone: zone,
      numNodes: numNodes,
      machineType: machineType,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async deleteCluster(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const zone = params.zone || 'us-central1-a';

    if (!name) {
      throw new Error('Cluster name required: DELETE CLUSTER name=... zone=...');
    }

    const result = await this.executeGcloud([
      'container', 'clusters', 'delete', name,
      '--zone', zone,
      '--quiet',
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'delete_cluster',
      cluster: name,
      zone: zone,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async listClusters(command) {
    const params = parseKeyValueParams(command);
    const zone = params.zone; // Optional - list all if not specified

    const args = ['container', 'clusters', 'list', '--format', 'json'];

    if (zone) {
      args.push('--zone', zone);
    }

    const result = await this.executeGcloud(args);

    let clusters = [];
    if (result.success && result.stdout) {
      try {
        clusters = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'list_clusters',
      zone: zone || 'all',
      clusters: clusters,
      count: clusters.length || 0,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async describeCluster(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const zone = params.zone || 'us-central1-a';

    if (!name) {
      throw new Error('Cluster name required: DESCRIBE CLUSTER name=... zone=...');
    }

    const result = await this.executeGcloud([
      'container', 'clusters', 'describe', name,
      '--zone', zone,
      '--format', 'json'
    ]);

    let clusterData = null;
    if (result.success && result.stdout) {
      try {
        clusterData = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'describe_cluster',
      cluster: name,
      zone: zone,
      data: clusterData,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async getCredentials(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const zone = params.zone || 'us-central1-a';

    if (!name) {
      throw new Error('Cluster name required: GET CREDENTIALS name=... zone=...');
    }

    const result = await this.executeGcloud([
      'container', 'clusters', 'get-credentials', name,
      '--zone', zone
    ]);

    return {
      success: result.success,
      action: 'get_credentials',
      cluster: name,
      zone: zone,
      message: 'Kubeconfig updated - you can now use kubectl',
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async resizeCluster(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const numNodes = params['num-nodes'];
    const zone = params.zone || 'us-central1-a';

    if (!name || !numNodes) {
      throw new Error('Cluster name and num-nodes required: RESIZE CLUSTER name=... num-nodes=... zone=...');
    }

    const result = await this.executeGcloud([
      'container', 'clusters', 'resize', name,
      '--num-nodes', numNodes,
      '--zone', zone,
      '--quiet',
      '--format', 'json'
    ]);

    return {
      success: result.success,
      action: 'resize_cluster',
      cluster: name,
      numNodes: numNodes,
      zone: zone,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async upgradeCluster(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const zone = params.zone || 'us-central1-a';
    const version = params.version; // Optional - upgrades to latest if not specified

    if (!name) {
      throw new Error('Cluster name required: UPGRADE CLUSTER name=... zone=... [version=...]');
    }

    const args = [
      'container', 'clusters', 'upgrade', name,
      '--zone', zone,
      '--quiet',
      '--format', 'json'
    ];

    if (version) {
      args.push('--cluster-version', version);
    } else {
      args.push('--master');
    }

    const result = await this.executeGcloud(args);

    return {
      success: result.success,
      action: 'upgrade_cluster',
      cluster: name,
      zone: zone,
      version: version || 'latest',
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async listNodePools(command) {
    const params = parseKeyValueParams(command);
    const cluster = params.cluster;
    const zone = params.zone || 'us-central1-a';

    if (!cluster) {
      throw new Error('Cluster name required: LIST NODE-POOLS cluster=... zone=...');
    }

    const result = await this.executeGcloud([
      'container', 'node-pools', 'list',
      '--cluster', cluster,
      '--zone', zone,
      '--format', 'json'
    ]);

    let nodePools = [];
    if (result.success && result.stdout) {
      try {
        nodePools = JSON.parse(result.stdout);
      } catch (e) {
        // Return raw output
      }
    }

    return {
      success: result.success,
      action: 'list_node_pools',
      cluster: cluster,
      zone: zone,
      nodePools: nodePools,
      count: nodePools.length || 0,
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  getInfo() {
    return {
      success: true,
      service: 'GKE (Google Kubernetes Engine)',
      description: 'Managed Kubernetes clusters',
      capabilities: [
        'CREATE CLUSTER - Create a GKE cluster',
        'DELETE CLUSTER - Delete a cluster',
        'LIST CLUSTERS - List all clusters',
        'DESCRIBE CLUSTER - Get cluster details',
        'GET CREDENTIALS - Configure kubectl',
        'RESIZE CLUSTER - Change node count',
        'UPGRADE CLUSTER - Upgrade Kubernetes version',
        'LIST NODE-POOLS - List node pools'
      ],
      examples: {
        'Create cluster': 'GKE CREATE CLUSTER name=my-cluster num-nodes=3 zone=us-central1-a',
        'Get credentials': 'GKE GET CREDENTIALS name=my-cluster zone=us-central1-a',
        'Resize cluster': 'GKE RESIZE CLUSTER name=my-cluster num-nodes=5'
      }
    };
  }

  async executeGcloud(args) {
    return await this.parent.execCommand('gcloud', args);
  }
}

// Load Balancing Handler - extracted to gcp-handlers/load-balancing-handler.js

// CloudCDNHandler - extracted to gcp-handlers/cloud-cdn-handler.js

// CloudArmorHandler - extracted to gcp-handlers/cloud-armor-handler.js

// CloudMemorystoreHandler - extracted to gcp-handlers/memorystore-handler.js

// Cloud Bigtable Handler - extracted to gcp-handlers/bigtable-handler.js

// ============================================
// Cloud Spanner Handler
// ============================================

class CloudSpannerHandler {
  constructor(parent) {
    this.parent = parent;
  }

  async initialize() {
    // No special initialization needed
  }

  async handle(command) {
    const upperCommand = command.toUpperCase().trim();

    // Instances
    if (upperCommand.startsWith('CREATE INSTANCE')) {
      return await this.createInstance(command);
    }
    if (upperCommand.startsWith('DELETE INSTANCE')) {
      return await this.deleteInstance(command);
    }
    if (upperCommand.startsWith('LIST INSTANCES')) {
      return await this.listInstances(command);
    }
    if (upperCommand.startsWith('DESCRIBE INSTANCE')) {
      return await this.describeInstance(command);
    }
    if (upperCommand.startsWith('UPDATE INSTANCE')) {
      return await this.updateInstance(command);
    }

    // Databases
    if (upperCommand.startsWith('CREATE DATABASE')) {
      return await this.createDatabase(command);
    }
    if (upperCommand.startsWith('DELETE DATABASE')) {
      return await this.deleteDatabase(command);
    }
    if (upperCommand.startsWith('LIST DATABASES')) {
      return await this.listDatabases(command);
    }
    if (upperCommand.startsWith('DESCRIBE DATABASE')) {
      return await this.describeDatabase(command);
    }

    // DDL operations
    if (upperCommand.startsWith('DDL')) {
      return await this.executeDdl(command);
    }

    // Backups
    if (upperCommand.startsWith('CREATE BACKUP')) {
      return await this.createBackup(command);
    }
    if (upperCommand.startsWith('DELETE BACKUP')) {
      return await this.deleteBackup(command);
    }
    if (upperCommand.startsWith('LIST BACKUPS')) {
      return await this.listBackups(command);
    }
    if (upperCommand.startsWith('RESTORE')) {
      return await this.restoreBackup(command);
    }

    // Query
    if (upperCommand.startsWith('QUERY')) {
      return await this.executeQuery(command);
    }

    throw new Error('Unknown Cloud Spanner command: ' + command);
  }

  async createInstance(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;
    const config = params.config;

    if (!name || !config) {
      throw new Error('Instance name and config are required');
    }

    const args = ['spanner', 'instances', 'create', name];
    args.push('--config', config);

    if (params['display-name']) {
      args.push('--display-name', params['display-name']);
    }

    if (params.nodes) {
      args.push('--nodes', params.nodes);
    }

    if (params['processing-units']) {
      args.push('--processing-units', params['processing-units']);
    }

    if (params.description) {
      args.push('--description', params.description);
    }

    if (params.async === 'true') {
      args.push('--async');
    }

    const result = await this.executeGcloud(args);

    return {
      success: result.exitCode === 0,
      action: 'create_instance',
      data: { name, config },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async deleteInstance(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;

    if (!name) {
      throw new Error('Instance name is required');
    }

    const args = ['spanner', 'instances', 'delete', name, '--quiet'];
    const result = await this.executeGcloud(args);

    return {
      success: result.exitCode === 0,
      action: 'delete_instance',
      data: { name },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async listInstances(command) {
    const args = ['spanner', 'instances', 'list', '--format', 'json'];
    const result = await this.executeGcloud(args);

    let instances = [];
    if (result.exitCode === 0 && result.stdout) {
      try {
        instances = JSON.parse(result.stdout);
      } catch (e) {
        // Fallback to raw output
      }
    }

    return {
      success: result.exitCode === 0,
      action: 'list_instances',
      data: { instances, count: instances.length },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async describeInstance(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;

    if (!name) {
      throw new Error('Instance name is required');
    }

    const args = ['spanner', 'instances', 'describe', name, '--format', 'json'];
    const result = await this.executeGcloud(args);

    let instance = null;
    if (result.exitCode === 0 && result.stdout) {
      try {
        instance = JSON.parse(result.stdout);
      } catch (e) {
        // Fallback to raw output
      }
    }

    return {
      success: result.exitCode === 0,
      action: 'describe_instance',
      data: { name, instance },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async updateInstance(command) {
    const params = parseKeyValueParams(command);
    const name = params.name;

    if (!name) {
      throw new Error('Instance name is required');
    }

    const args = ['spanner', 'instances', 'update', name];

    if (params.nodes) {
      args.push('--nodes', params.nodes);
    }

    if (params['processing-units']) {
      args.push('--processing-units', params['processing-units']);
    }

    if (params.description) {
      args.push('--description', params.description);
    }

    if (params.async === 'true') {
      args.push('--async');
    }

    const result = await this.executeGcloud(args);

    return {
      success: result.exitCode === 0,
      action: 'update_instance',
      data: { name },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async createDatabase(command) {
    const params = parseKeyValueParams(command);
    const database = params.database;
    const instance = params.instance;

    if (!database || !instance) {
      throw new Error('Database name and instance name are required');
    }

    const args = ['spanner', 'databases', 'create', database];
    args.push('--instance', instance);

    if (params.ddl) {
      args.push('--ddl', params.ddl);
    }

    if (params.async === 'true') {
      args.push('--async');
    }

    const result = await this.executeGcloud(args);

    return {
      success: result.exitCode === 0,
      action: 'create_database',
      data: { database, instance },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async deleteDatabase(command) {
    const params = parseKeyValueParams(command);
    const database = params.database;
    const instance = params.instance;

    if (!database || !instance) {
      throw new Error('Database name and instance name are required');
    }

    const args = ['spanner', 'databases', 'delete', database];
    args.push('--instance', instance);
    args.push('--quiet');

    const result = await this.executeGcloud(args);

    return {
      success: result.exitCode === 0,
      action: 'delete_database',
      data: { database, instance },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async listDatabases(command) {
    const params = parseKeyValueParams(command);
    const instance = params.instance;

    if (!instance) {
      throw new Error('Instance name is required');
    }

    const args = ['spanner', 'databases', 'list'];
    args.push('--instance', instance);
    args.push('--format', 'json');

    const result = await this.executeGcloud(args);

    let databases = [];
    if (result.exitCode === 0 && result.stdout) {
      try {
        databases = JSON.parse(result.stdout);
      } catch (e) {
        // Fallback to raw output
      }
    }

    return {
      success: result.exitCode === 0,
      action: 'list_databases',
      data: { instance, databases, count: databases.length },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async describeDatabase(command) {
    const params = parseKeyValueParams(command);
    const database = params.database;
    const instance = params.instance;

    if (!database || !instance) {
      throw new Error('Database name and instance name are required');
    }

    const args = ['spanner', 'databases', 'describe', database];
    args.push('--instance', instance);
    args.push('--format', 'json');

    const result = await this.executeGcloud(args);

    let db = null;
    if (result.exitCode === 0 && result.stdout) {
      try {
        db = JSON.parse(result.stdout);
      } catch (e) {
        // Fallback to raw output
      }
    }

    return {
      success: result.exitCode === 0,
      action: 'describe_database',
      data: { database, instance, db },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async executeDdl(command) {
    const params = parseKeyValueParams(command);
    const database = params.database;
    const instance = params.instance;
    const ddl = params.ddl;

    if (!database || !instance || !ddl) {
      throw new Error('Database name, instance name, and DDL statement are required');
    }

    const args = ['spanner', 'databases', 'ddl', 'update', database];
    args.push('--instance', instance);
    args.push('--ddl', ddl);

    if (params.async === 'true') {
      args.push('--async');
    }

    const result = await this.executeGcloud(args);

    return {
      success: result.exitCode === 0,
      action: 'execute_ddl',
      data: { database, instance, ddl },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async createBackup(command) {
    const params = parseKeyValueParams(command);
    const backup = params.backup;
    const instance = params.instance;
    const database = params.database;

    if (!backup || !instance || !database) {
      throw new Error('Backup name, instance name, and database name are required');
    }

    const args = ['spanner', 'backups', 'create', backup];
    args.push('--instance', instance);
    args.push('--database', database);

    if (params['retention-period']) {
      args.push('--retention-period', params['retention-period']);
    }

    if (params.async === 'true') {
      args.push('--async');
    }

    const result = await this.executeGcloud(args);

    return {
      success: result.exitCode === 0,
      action: 'create_backup',
      data: { backup, instance, database },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async deleteBackup(command) {
    const params = parseKeyValueParams(command);
    const backup = params.backup;
    const instance = params.instance;

    if (!backup || !instance) {
      throw new Error('Backup name and instance name are required');
    }

    const args = ['spanner', 'backups', 'delete', backup];
    args.push('--instance', instance);
    args.push('--quiet');

    const result = await this.executeGcloud(args);

    return {
      success: result.exitCode === 0,
      action: 'delete_backup',
      data: { backup, instance },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async listBackups(command) {
    const params = parseKeyValueParams(command);
    const instance = params.instance;

    if (!instance) {
      throw new Error('Instance name is required');
    }

    const args = ['spanner', 'backups', 'list'];
    args.push('--instance', instance);
    args.push('--format', 'json');

    const result = await this.executeGcloud(args);

    let backups = [];
    if (result.exitCode === 0 && result.stdout) {
      try {
        backups = JSON.parse(result.stdout);
      } catch (e) {
        // Fallback to raw output
      }
    }

    return {
      success: result.exitCode === 0,
      action: 'list_backups',
      data: { instance, backups, count: backups.length },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async restoreBackup(command) {
    const params = parseKeyValueParams(command);
    const backup = params.backup;
    const sourceInstance = params['source-instance'];
    const destinationDatabase = params['destination-database'];
    const destinationInstance = params['destination-instance'];

    if (!backup || !sourceInstance || !destinationDatabase || !destinationInstance) {
      throw new Error('Backup, source instance, destination database, and destination instance are required');
    }

    const args = ['spanner', 'backups', 'restore', backup];
    args.push('--source-instance', sourceInstance);
    args.push('--destination-database', destinationDatabase);
    args.push('--destination-instance', destinationInstance);

    if (params.async === 'true') {
      args.push('--async');
    }

    const result = await this.executeGcloud(args);

    return {
      success: result.exitCode === 0,
      action: 'restore_backup',
      data: { backup, sourceInstance, destinationDatabase, destinationInstance },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  async executeQuery(command) {
    const params = parseKeyValueParams(command);
    const database = params.database;
    const instance = params.instance;
    const sql = params.sql;

    if (!database || !instance || !sql) {
      throw new Error('Database name, instance name, and SQL query are required');
    }

    const args = ['spanner', 'databases', 'execute-sql', database];
    args.push('--instance', instance);
    args.push('--sql', sql);
    args.push('--format', 'json');

    const result = await this.executeGcloud(args);

    let rows = [];
    if (result.exitCode === 0 && result.stdout) {
      try {
        const response = JSON.parse(result.stdout);
        rows = response.rows || [];
      } catch (e) {
        // Fallback to raw output
      }
    }

    return {
      success: result.exitCode === 0,
      action: 'execute_query',
      data: { database, instance, sql, rows, rowCount: rows.length },
      stdout: result.stdout,
      stderr: result.stderr
    };
  }

  getInfo() {
    return {
      service: 'spanner',
      description: 'Cloud Spanner - Globally distributed, strongly consistent relational database',
      commands: {
        'Create instance': 'SPANNER CREATE INSTANCE name=my-instance config=regional-us-central1 nodes=1',
        'List instances': 'SPANNER LIST INSTANCES',
        'Create database': 'SPANNER CREATE DATABASE database=my-db instance=my-instance',
        'List databases': 'SPANNER LIST DATABASES instance=my-instance',
        'Execute DDL': 'SPANNER DDL database=my-db instance=my-instance ddl="CREATE TABLE Users (id INT64, name STRING(100)) PRIMARY KEY (id)"',
        'Execute query': 'SPANNER QUERY database=my-db instance=my-instance sql="SELECT * FROM Users"',
        'Create backup': 'SPANNER CREATE BACKUP backup=my-backup instance=my-instance database=my-db retention-period=7d',
        'Restore backup': 'SPANNER RESTORE backup=my-backup source-instance=my-instance destination-database=restored-db destination-instance=my-instance'
      }
    };
  }

  async executeGcloud(args) {
    return await this.parent.execCommand('gcloud', args);
  }
}

// ============================================
// Unified GCP Handler
// ============================================

class UnifiedGcpHandler {
  constructor() {
    this.runtime = 'gcp';
    this.project = null; // Will be set from gcloud config or params
    this.region = 'us-central1';

    // Service handlers - lazy loaded for better modularity
    this.services = {
      sheets: null, // Lazy loaded from gcp-handlers/sheets-handler.js
      docs: null, // Lazy loaded from gcp-handlers/docs-handler.js
      slides: null, // Lazy loaded from gcp-handlers/slides-handler.js
      apps_script: null, // Lazy loaded from gcp-handlers/apps-script-handler.js
      bigquery: null, // Lazy loaded from gcp-handlers/bigquery-handler.js
      billing: null, // Lazy loaded from gcp-handlers/billing-handler.js
      firestore: new FirestoreHandler(this),
      storage: new StorageHandler(this),
      pubsub: new PubSubHandler(this),
      functions: new FunctionsHandler(this),
      run: new CloudRunHandler(this),
      compute: new ComputeEngineHandler(this),
      monitoring: new MonitoringHandler(this),
      logging: new LoggingHandler(this),
      iam: new IAMHandler(this),
      sql: new CloudSQLHandler(this),
      vpc: new VPCHandler(this),
      dns: new DNSHandler(this),
      secrets: new SecretManagerHandler(this),
      kms: null, // Lazy loaded from gcp-handlers/cloud-kms-handler.js
      tasks: new CloudTasksHandler(this),
      scheduler: new CloudSchedulerHandler(this),
      artifactRegistry: new ArtifactRegistryHandler(this),
      gke: new GKEHandler(this),
      loadBalancing: null, // Lazy loaded from gcp-handlers/load-balancing-handler.js
      cdn: null, // Lazy loaded from gcp-handlers/cloud-cdn-handler.js
      armor: null, // Lazy loaded from gcp-handlers/cloud-armor-handler.js
      memorystore: null, // Lazy loaded from gcp-handlers/memorystore-handler.js
      bigtable: null, // Lazy loaded from gcp-handlers/bigtable-handler.js
      spanner: new CloudSpannerHandler(this),
      // Legacy handlers for backward compatibility
      activeFunctions: new Map(),
      activeServices: new Map()
    };

    // Legacy settings for backward compatibility
    this.functionDefaults = {
      runtime: 'python311',
      memory: '256MB',
      timeout: '60s',
      maxInstances: 100,
      minInstances: 0,
      trigger: 'http'
    };

    this.cloudRunDefaults = {
      platform: 'managed',
      memory: '512Mi',
      cpu: '1',
      maxInstances: 100,
      minInstances: 0,
      port: 8080
    };

    this.auditLog = [];

    // Child process reference
    this.spawn = spawn;
    this.fs = fs;
    this.path = path;
  }

  async initialize(config = {}) {
    // Merge configuration
    Object.assign(this, config);

    // Auto-detect project if not set
    if (!this.project) {
      try {
        const result = await this.execCommand('gcloud', ['config', 'get-value', 'project']);
        if (result.stdout && result.stdout.trim()) {
          this.project = result.stdout.trim();
        }
      } catch (e) {
        // Project will need to be set explicitly
      }
    }

    // Initialize service handlers (skip null/lazy-loaded services)
    for (const service of Object.values(this.services)) {
      if (service && typeof service.initialize === 'function') {
        await service.initialize();
      }
    }

    return this;
  }

  // Lazy load service handlers for better modularity
  getServiceHandler(serviceName) {
    if (this.services[serviceName] === null) {
      // Lazy load the handler
      const handlerMap = {
        loadBalancing: './gcp-handlers/load-balancing-handler.js',
        bigtable: './gcp-handlers/bigtable-handler.js',
        memorystore: './gcp-handlers/memorystore-handler.js',
        armor: './gcp-handlers/cloud-armor-handler.js',
        cdn: './gcp-handlers/cloud-cdn-handler.js',
        kms: './gcp-handlers/cloud-kms-handler.js'
      };

      if (handlerMap[serviceName]) {
        const HandlerClass = require(handlerMap[serviceName]);
        this.services[serviceName] = new HandlerClass(this);
        // Initialize if needed
        if (typeof this.services[serviceName].initialize === 'function') {
          this.services[serviceName].initialize();
        }
      }
    }
    return this.services[serviceName];
  }
  async ensureSheetsHandler() {
    if (!this.services.sheets) {
      const { SheetsHandler } = require('./gcp-handlers/sheets-handler.js');
      this.services.sheets = new SheetsHandler(this, parseKeyValueParams);
      if (typeof this.services.sheets.initialize === 'function') {
        await this.services.sheets.initialize();
      }
    }
    return this.services.sheets;
  }

  async ensureAppsScriptHandler() {
    if (!this.services.apps_script) {
      const { AppsScriptHandler } = require('./gcp-handlers/apps-script-handler.js');
      this.services.apps_script = new AppsScriptHandler(this, parseKeyValueParams);
      if (typeof this.services.apps_script.initialize === 'function') {
        await this.services.apps_script.initialize();
      }
    }
    return this.services.apps_script;
  }

  async ensureBigQueryHandler() {
    if (!this.services.bigquery) {
      const { BigQueryHandler } = require('./gcp-handlers/bigquery-handler.js');
      this.services.bigquery = new BigQueryHandler(this, parseKeyValueParams);
      if (typeof this.services.bigquery.initialize === 'function') {
        await this.services.bigquery.initialize();
      }
    }
    return this.services.bigquery;
  }

  async ensureBillingHandler() {
    if (!this.services.billing) {
      const { BillingHandler } = require('./gcp-handlers/billing-handler.js');
      this.services.billing = new BillingHandler(this, parseKeyValueParams);
      if (typeof this.services.billing.initialize === 'function') {
        await this.services.billing.initialize();
      }
    }
    return this.services.billing;
  }

  async ensureDocsHandler() {
    if (!this.services.docs) {
      const { DocsHandler } = require('./gcp-handlers/docs-handler.js');
      this.services.docs = new DocsHandler(this, parseKeyValueParams);
      if (typeof this.services.docs.initialize === 'function') {
        await this.services.docs.initialize();
      }
    }
    return this.services.docs;
  }

  async ensureSlidesHandler() {
    if (!this.services.slides) {
      const { SlidesHandler } = require('./gcp-handlers/slides-handler.js');
      this.services.slides = new SlidesHandler(this, parseKeyValueParams);
      if (typeof this.services.slides.initialize === 'function') {
        await this.services.slides.initialize();
      }
    }
    return this.services.slides;
  }

  async getAuth(scopes) {
    // Use Google Application Default Credentials
    // This will automatically use GOOGLE_APPLICATION_CREDENTIALS env var
    try {
      const { GoogleAuth } = require('google-auth-library');
      console.log('[GCP Auth] GOOGLE_APPLICATION_CREDENTIALS:', process.env.GOOGLE_APPLICATION_CREDENTIALS);

      // Default scopes if none provided
      const authScopes = scopes || [
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.readonly'
      ];

      const auth = new GoogleAuth({
        scopes: authScopes
      });
      const client = await auth.getClient();
      console.log('[GCP Auth] Successfully created auth client with scopes:', authScopes);
      return client;
    } catch (e) {
      console.error('[GCP Auth] Failed to get Google auth:', e.message);
      return null;
    }
  }

  // New unified execute method for string commands
  async execute(command) {
    const trimmed = command.trim();

    if (!trimmed) {
      throw new Error('Empty command');
    }

    // Extract service identifier
    const firstWord = trimmed.split(/\s+/)[0].toUpperCase();

    // Handle rate limiting commands first
    if (firstWord === 'RATELIMIT') {
      return await this.handleRateLimit(trimmed.substring(9).trim());
    }

    // Route to appropriate service handler (no shorthand codes)
    switch (firstWord) {
      case 'SHEET':
      case 'SHEETS':
        await globalRateLimiter.checkLimit('sheets');
        const sheetsHandler = await this.ensureSheetsHandler();
        return await sheetsHandler.handle(trimmed.substring(firstWord.length).trim());

      case 'DOC':
      case 'DOCS':
        await globalRateLimiter.checkLimit('docs');
        const docsHandler = await this.ensureDocsHandler();
        return await docsHandler.execute(trimmed.substring(firstWord.length).trim());

      case 'SLIDE':
      case 'SLIDES':
        await globalRateLimiter.checkLimit('slides');
        const slidesHandler = await this.ensureSlidesHandler();
        return await slidesHandler.execute(trimmed.substring(firstWord.length).trim());

      case 'BIGQUERY':
        await globalRateLimiter.checkLimit('bigquery');
        const bigqueryHandler = await this.ensureBigQueryHandler();
        return await bigqueryHandler.handle(trimmed.substring(firstWord.length).trim());

      case 'BILLING':
        await globalRateLimiter.checkLimit('billing');
        const billingHandler = await this.ensureBillingHandler();
        return await billingHandler.execute(trimmed.substring(firstWord.length).trim());

      case 'FIRESTORE':
        await globalRateLimiter.checkLimit('firestore');
        return await this.services.firestore.handle(trimmed.substring(firstWord.length).trim());

      case 'STORAGE':
        await globalRateLimiter.checkLimit('storage');
        return await this.services.storage.handle(trimmed.substring(firstWord.length).trim());

      case 'PUBSUB':
        await globalRateLimiter.checkLimit('pubsub');
        return await this.services.pubsub.handle(trimmed.substring(firstWord.length).trim());

      case 'FUNCTIONS':
      case 'FUNCTION':
        await globalRateLimiter.checkLimit('functions');
        return await this.services.functions.handle(trimmed.substring(firstWord.length).trim());

      case 'RUN':
        await globalRateLimiter.checkLimit('run');
        return await this.services.run.handle(trimmed.substring(firstWord.length).trim());

      case 'APPS_SCRIPT':
        await globalRateLimiter.checkLimit('apps_script');
        const appsScriptHandler = await this.ensureAppsScriptHandler();
        return await appsScriptHandler.execute(trimmed.substring(firstWord.length).trim());

      case 'COMPUTE':
        await globalRateLimiter.checkLimit('compute');
        return await this.services.compute.handle(trimmed.substring(firstWord.length).trim());

      case 'MONITORING':
        await globalRateLimiter.checkLimit('monitoring');
        return await this.services.monitoring.handle(trimmed.substring(firstWord.length).trim());

      case 'LOGGING':
        await globalRateLimiter.checkLimit('logging');
        return await this.services.logging.handle(trimmed.substring(firstWord.length).trim());

      case 'IAM':
        await globalRateLimiter.checkLimit('iam');
        return await this.services.iam.handle(trimmed.substring(firstWord.length).trim());

      case 'SQL':
        await globalRateLimiter.checkLimit('sql');
        return await this.services.sql.handle(trimmed.substring(firstWord.length).trim());

      case 'VPC':
      case 'NETWORK':
        await globalRateLimiter.checkLimit('vpc');
        return await this.services.vpc.handle(trimmed.substring(firstWord.length).trim());

      case 'DNS':
        await globalRateLimiter.checkLimit('dns');
        return await this.services.dns.handle(trimmed.substring(firstWord.length).trim());

      case 'SECRET':
      case 'SECRETS':
        await globalRateLimiter.checkLimit('secrets');
        return await this.services.secrets.handle(trimmed.substring(firstWord.length).trim());

      case 'KMS':
        await globalRateLimiter.checkLimit('kms');
        return await this.getServiceHandler('kms').handle(trimmed.substring(firstWord.length).trim());

      case 'TASKS':
        await globalRateLimiter.checkLimit('tasks');
        return await this.services.tasks.handle(trimmed.substring(firstWord.length).trim());

      case 'SCHEDULER':
        await globalRateLimiter.checkLimit('scheduler');
        return await this.services.scheduler.handle(trimmed.substring(firstWord.length).trim());

      case 'ARTIFACT-REGISTRY':
      case 'ARTIFACTS':
        await globalRateLimiter.checkLimit('artifactRegistry');
        return await this.services.artifactRegistry.handle(trimmed.substring(firstWord.length).trim());

      case 'GKE':
      case 'KUBERNETES':
        await globalRateLimiter.checkLimit('gke');
        return await this.services.gke.handle(trimmed.substring(firstWord.length).trim());

      case 'LOAD-BALANCING':
      case 'LB':
        await globalRateLimiter.checkLimit('loadBalancing');
        return await this.getServiceHandler('loadBalancing').handle(trimmed.substring(firstWord.length).trim());

      case 'CDN':
        await globalRateLimiter.checkLimit('cdn');
        return await this.getServiceHandler('cdn').handle(trimmed.substring(firstWord.length).trim());

      case 'ARMOR':
      case 'SECURITY':
        await globalRateLimiter.checkLimit('armor');
        return await this.getServiceHandler('armor').handle(trimmed.substring(firstWord.length).trim());

      case 'MEMORYSTORE':
      case 'REDIS':
      case 'MEMCACHED':
        await globalRateLimiter.checkLimit('memorystore');
        return await this.getServiceHandler('memorystore').handle(trimmed.substring(firstWord.length).trim());

      case 'BIGTABLE':
        await globalRateLimiter.checkLimit('bigtable');
        return await this.getServiceHandler('bigtable').handle(trimmed.substring(firstWord.length).trim());

      case 'SPANNER':
        await globalRateLimiter.checkLimit('spanner');
        return await this.services.spanner.handle(trimmed.substring(firstWord.length).trim());

      // Legacy gcloud-like syntax for backward compatibility
      case 'DEPLOY':
      case 'LIST':
      case 'DELETE':
      case 'CREATE':
        await globalRateLimiter.checkLimit('global');
        return await this.handleLegacyCommand(trimmed);

      default:
        throw new Error(`Unknown GCP service: ${firstWord}. Available services: SHEETS, DOCS, SLIDES, APPS_SCRIPT, BIGQUERY, BILLING, FIRESTORE, STORAGE, PUBSUB, FUNCTIONS, RUN, COMPUTE, MONITORING, LOGGING, IAM, SQL, VPC, DNS, SECRETS, KMS, TASKS, SCHEDULER, ARTIFACT-REGISTRY, GKE, RATELIMIT`);
    }
  }

  async handleRateLimit(command) {
    const trimmed = command.trim();
    const upperCommand = trimmed.toUpperCase();

    // RATELIMIT ENABLE
    if (upperCommand === 'ENABLE') {
      globalRateLimiter.enable();
      return {
        success: true,
        action: 'enabled',
        message: 'Rate limiting enabled for all GCP services'
      };
    }

    // RATELIMIT DISABLE
    if (upperCommand === 'DISABLE') {
      globalRateLimiter.disable();
      return {
        success: true,
        action: 'disabled',
        message: 'Rate limiting disabled for all GCP services'
      };
    }

    // RATELIMIT STATUS
    if (upperCommand === 'STATUS') {
      return {
        success: true,
        action: 'status',
        ...globalRateLimiter.getStatus()
      };
    }

    // RATELIMIT RESET [service]
    if (upperCommand.startsWith('RESET')) {
      const parts = trimmed.split(/\s+/);
      const service = parts[1] ? parts[1].toLowerCase() : null;
      globalRateLimiter.reset(service);
      return {
        success: true,
        action: 'reset',
        service: service || 'all',
        message: service ? `Rate limit counter reset for ${service}` : 'All rate limit counters reset'
      };
    }

    // RATELIMIT SET service requests window_seconds
    if (upperCommand.startsWith('SET ')) {
      const parts = trimmed.split(/\s+/);
      if (parts.length < 4) {
        throw new Error('Invalid RATELIMIT SET syntax. Use: RATELIMIT SET service requests window_seconds');
      }

      const service = parts[1].toLowerCase();
      const requests = parseInt(parts[2]);
      const windowSeconds = parseInt(parts[3]);

      if (isNaN(requests) || isNaN(windowSeconds) || requests <= 0 || windowSeconds <= 0) {
        throw new Error('Requests and window_seconds must be positive numbers');
      }

      const windowMs = windowSeconds * 1000;
      const success = globalRateLimiter.setLimit(service, requests, windowMs);

      if (!success) {
        throw new Error(`Unknown service: ${service}. Available services: global, sheets, bigquery, firestore, storage, pubsub, functions, run`);
      }

      return {
        success: true,
        action: 'set_limit',
        service,
        requests,
        windowSeconds,
        message: `Rate limit set for ${service}: ${requests} requests per ${windowSeconds} seconds`
      };
    }

    // RATELIMIT help or unknown command
    if (upperCommand === 'HELP' || !trimmed) {
      return {
        success: true,
        action: 'help',
        commands: {
          'RATELIMIT ENABLE': 'Enable rate limiting for all services',
          'RATELIMIT DISABLE': 'Disable rate limiting for all services',
          'RATELIMIT STATUS': 'Show current rate limit status and usage',
          'RATELIMIT RESET [service]': 'Reset rate limit counters (all services or specific service)',
          'RATELIMIT SET service requests window_seconds': 'Set rate limit for a service',
          'RATELIMIT HELP': 'Show this help message'
        },
        services: ['global', 'sheets', 'bigquery', 'firestore', 'storage', 'pubsub', 'functions', 'run', 'compute', 'monitoring', 'logging', 'iam', 'sql', 'vpc', 'dns', 'secrets', 'kms', 'tasks', 'scheduler', 'artifactRegistry', 'gke'],
        examples: {
          'Enable rate limiting': 'RATELIMIT ENABLE',
          'Set sheets limit to 50 requests per 30 seconds': 'RATELIMIT SET sheets 50 30',
          'Check current status': 'RATELIMIT STATUS',
          'Reset all counters': 'RATELIMIT RESET',
          'Reset only sheets counter': 'RATELIMIT RESET sheets'
        }
      };
    }

    throw new Error(`Unknown RATELIMIT command: ${trimmed.split(' ')[0]}. Use RATELIMIT HELP for available commands.`);
  }

  async handleLegacyCommand(command) {
    // Handle legacy gcloud-like commands for backward compatibility
    const parts = command.split(/\s+/);
    const action = parts[0].toLowerCase();
    const resource = parts[1] ? parts[1].toLowerCase() : '';

    // Parse remaining arguments
    const params = {};
    let currentArg = null;

    for (let i = 2; i < parts.length; i++) {
      const part = parts[i];
      if (part.startsWith('--')) {
        currentArg = part.substring(2);
        params[currentArg] = true;
      } else if (currentArg) {
        params[currentArg] = part;
      } else {
        if (!params.name) {
          params.name = part;
        }
      }
    }

    // Map to legacy methods
    const method = `${action}_${resource}`;
    return await this.handle(method, params);
  }

  // Core execution method
  async execCommand(command, args = [], options = {}) {
    // Apply global rate limiting to all gcloud commands
    await globalRateLimiter.checkLimit('global');
    
    return new Promise((resolve, reject) => {
      const proc = this.spawn(command, args, {
        stdio: ['pipe', 'pipe', 'pipe'],
        ...options
      });

      let stdout = '';
      let stderr = '';

      proc.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      proc.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      proc.on('close', (code) => {
        if (code === 0) {
          resolve({ success: true, stdout: stdout.trim(), stderr: stderr.trim() });
        } else {
          resolve({
            success: false,
            stdout: stdout.trim(),
            stderr: stderr.trim(),
            exitCode: code
          });
        }
      });

      proc.on('error', (err) => {
        reject(err);
      });
    });
  }

  // Cloud Functions operations
  async deployFunction(params, context) {
    const functionName = params.name || `rexx-function-${Date.now()}`;
    const source = params.source || '.';
    const runtime = params.runtime || this.functionDefaults.runtime;
    const entryPoint = params.entry_point || 'main';
    const trigger = params.trigger || this.functionDefaults.trigger;

    // Validate runtime - allow common runtimes
    const allowedRuntimes = new Set([
      'python311', 'python39', 'python38', 'python37',
      'nodejs18', 'nodejs16', 'nodejs14', 'nodejs12',
      'go119', 'go116', 'go113',
      'java17', 'java11',
      'dotnet6', 'dotnet3',
      'ruby30', 'ruby27'
    ]);
    
    if (!allowedRuntimes.has(runtime)) {
      throw new Error(`Unsupported runtime: ${runtime}. Allowed: ${Array.from(allowedRuntimes).join(', ')}`);
    }

    // Build deployment command
    const args = ['functions', 'deploy', functionName];

    args.push('--runtime', runtime);
    args.push('--entry-point', entryPoint);
    args.push('--source', source);

    // Add trigger
    if (trigger === 'http') {
      args.push('--trigger-http');
      args.push('--allow-unauthenticated');
    } else if (trigger.startsWith('topic:')) {
      args.push('--trigger-topic', trigger.substring(6));
    } else if (trigger.startsWith('bucket:')) {
      args.push('--trigger-bucket', trigger.substring(7));
    }

    // Add optional parameters
    if (params.region) args.push('--region', params.region);
    if (params.memory) args.push('--memory', params.memory);
    if (params.timeout) args.push('--timeout', params.timeout);
    if (params.max_instances) args.push('--max-instances', params.max_instances);
    if (params.min_instances) args.push('--min-instances', params.min_instances);
    if (params.env_vars) {
      const envVars = Object.entries(params.env_vars)
        .map(([k, v]) => `${k}=${v}`)
        .join(',');
      args.push('--set-env-vars', envVars);
    }

    if (this.project) args.push('--project', this.project);

    const result = await this.execCommand('gcloud', args);

    if (result.success) {
      this.activeFunctions.set(functionName, {
        name: functionName,
        runtime,
        trigger,
        deployedAt: new Date().toISOString()
      });

      // Get function URL if HTTP triggered
      if (trigger === 'http') {
        const describeResult = await this.execCommand('gcloud', [
          'functions', 'describe', functionName,
          '--format', 'value(httpsTrigger.url)',
          '--project', this.project
        ]);

        if (describeResult.success && describeResult.stdout) {
          result.url = describeResult.stdout.trim();
        }
      }
    }

    return result;
  }

  async invokeFunction(name, data = null) {
    const args = ['functions', 'call', name];

    if (data !== null) {
      args.push('--data', JSON.stringify(data));
    }

    if (this.project) args.push('--project', this.project);

    return await this.execCommand('gcloud', args);
  }

  async deleteFunction(name) {
    const args = ['functions', 'delete', name, '--quiet'];

    if (this.project) args.push('--project', this.project);

    const result = await this.execCommand('gcloud', args);

    if (result.success) {
      this.activeFunctions.delete(name);
    }

    return result;
  }

  async listFunctions() {
    const args = ['functions', 'list', '--format', 'json'];

    if (this.project) args.push('--project', this.project);

    const result = await this.execCommand('gcloud', args);

    if (result.success) {
      try {
        result.functions = JSON.parse(result.stdout);
      } catch (e) {
        result.functions = [];
      }
    }

    return result;
  }

  // Cloud Run operations
  async deployService(params, context) {
    const serviceName = params.name || `rexx-service-${Date.now()}`;
    const image = params.image;

    if (!image) {
      throw new Error('Image is required for Cloud Run deployment');
    }

    const args = ['run', 'deploy', serviceName];

    args.push('--image', image);
    args.push('--platform', params.platform || this.cloudRunDefaults.platform);

    // Add configuration
    if (params.region) args.push('--region', params.region);
    if (params.memory) args.push('--memory', params.memory);
    if (params.cpu) args.push('--cpu', params.cpu);
    if (params.port) args.push('--port', params.port);
    if (params.max_instances) args.push('--max-instances', params.max_instances);
    if (params.min_instances) args.push('--min-instances', params.min_instances);

    // Allow unauthenticated by default for demo
    if (params.allow_unauthenticated !== false) {
      args.push('--allow-unauthenticated');
    }

    if (params.env_vars) {
      const envVars = Object.entries(params.env_vars)
        .map(([k, v]) => `${k}=${v}`)
        .join(',');
      args.push('--set-env-vars', envVars);
    }

    if (this.project) args.push('--project', this.project);

    const result = await this.execCommand('gcloud', args);

    if (result.success) {
      this.activeServices.set(serviceName, {
        name: serviceName,
        image,
        deployedAt: new Date().toISOString()
      });

      // Get service URL
      const describeResult = await this.execCommand('gcloud', [
        'run', 'services', 'describe', serviceName,
        '--platform', params.platform || this.cloudRunDefaults.platform,
        '--region', params.region || this.region,
        '--format', 'value(status.url)',
        '--project', this.project
      ]);

      if (describeResult.success && describeResult.stdout) {
        result.url = describeResult.stdout.trim();
      }
    }

    return result;
  }

  async deleteService(name, region = null) {
    const args = ['run', 'services', 'delete', name, '--quiet'];

    args.push('--platform', 'managed');
    if (region) args.push('--region', region);
    if (this.project) args.push('--project', this.project);

    const result = await this.execCommand('gcloud', args);

    if (result.success) {
      this.activeServices.delete(name);
    }

    return result;
  }

  async listServices(region = null) {
    const args = ['run', 'services', 'list', '--platform', 'managed', '--format', 'json'];

    if (region) args.push('--region', region);
    if (this.project) args.push('--project', this.project);

    const result = await this.execCommand('gcloud', args);

    if (result.success) {
      try {
        result.services = JSON.parse(result.stdout);
      } catch (e) {
        result.services = [];
      }
    }

    return result;
  }

  // Storage operations
  async createBucket(name, location = 'us-central1') {
    const args = ['storage', 'buckets', 'create', `gs://${name}`];

    args.push('--location', location);
    if (this.project) args.push('--project', this.project);

    return await this.execCommand('gcloud', args);
  }

  async uploadToBucket(bucketName, localFile, remotePath = null) {
    const destination = remotePath
      ? `gs://${bucketName}/${remotePath}`
      : `gs://${bucketName}/${path.basename(localFile)}`;

    const args = ['storage', 'cp', localFile, destination];

    if (this.project) args.push('--project', this.project);

    return await this.execCommand('gcloud', args);
  }

  async listBuckets() {
    const args = ['storage', 'buckets', 'list', '--format', 'json'];

    if (this.project) args.push('--project', this.project);

    const result = await this.execCommand('gcloud', args);

    if (result.success) {
      try {
        result.buckets = JSON.parse(result.stdout);
      } catch (e) {
        result.buckets = [];
      }
    }

    return result;
  }

  // Pub/Sub operations
  async createTopic(name) {
    const args = ['pubsub', 'topics', 'create', name];

    if (this.project) args.push('--project', this.project);

    return await this.execCommand('gcloud', args);
  }

  async publishMessage(topic, message) {
    const args = ['pubsub', 'topics', 'publish', topic];

    args.push('--message', JSON.stringify(message));
    if (this.project) args.push('--project', this.project);

    return await this.execCommand('gcloud', args);
  }

  // Deployment helper for RexxJS scripts
  async deployRexxFunction(scriptPath, functionName = null) {
    const script = this.fs.readFileSync(scriptPath, 'utf8');
    const name = functionName || `rexx-${path.basename(scriptPath, '.rexx')}-${Date.now()}`;

    // Create temporary directory for function
    const tempDir = `/tmp/gcp-function-${name}`;
    if (this.fs.existsSync(tempDir)) {
      this.fs.rmSync(tempDir, { recursive: true });
    }
    this.fs.mkdirSync(tempDir, { recursive: true });

    // Create Python wrapper for RexxJS
    const pythonWrapper = `
import json
import subprocess
import tempfile
import os

def main(request):
    """HTTP Cloud Function that executes RexxJS script."""

    # Get request data
    request_json = request.get_json(silent=True)
    request_args = request.args

    # Create temp file with RexxJS script
    with tempfile.NamedTemporaryFile(mode='w', suffix='.rexx', delete=False) as f:
        f.write('''${script}''')
        script_path = f.name

    try:
        # Execute RexxJS script
        result = subprocess.run(
            ['rexx', script_path],
            capture_output=True,
            text=True,
            timeout=30,
            env={**os.environ, 'GCP_REQUEST': json.dumps(request_json or {})}
        )

        # Parse output
        output = result.stdout.strip()

        # Try to parse as JSON, otherwise return as text
        try:
            response = json.loads(output)
            return response
        except:
            return {'output': output, 'exitCode': result.returncode}

    except subprocess.TimeoutExpired:
        return {'error': 'Script execution timeout'}, 500
    except Exception as e:
        return {'error': str(e)}, 500
    finally:
        # Clean up temp file
        if os.path.exists(script_path):
            os.unlink(script_path)
`;

    // Write wrapper to temp directory
    this.fs.writeFileSync(`${tempDir}/main.py`, pythonWrapper);

    // Create requirements.txt if needed
    const requirements = '';
    this.fs.writeFileSync(`${tempDir}/requirements.txt`, requirements);

    // Deploy function
    const result = await this.deployFunction({
      name,
      source: tempDir,
      runtime: 'python311',
      entry_point: 'main',
      trigger: 'http'
    });

    // Clean up temp directory
    if (this.fs.existsSync(tempDir)) {
      this.fs.rmSync(tempDir, { recursive: true });
    }

    return result;
  }

  // Main handler method
  async handle(method, params = {}, context = {}) {
    // Audit logging
    this.auditLog.push({
      timestamp: new Date().toISOString(),
      method,
      params: { ...params, project: this.project }
    });

    switch (method.toLowerCase()) {
      // Cloud Functions
      case 'deploy_function':
        return await this.deployFunction(params, context);
      case 'invoke_function':
        return await this.invokeFunction(params.name || params.function, params.data);
      case 'delete_function':
        return await this.deleteFunction(params.name || params.function);
      case 'list_functions':
        return await this.listFunctions();

      // Cloud Run
      case 'deploy_service':
        return await this.deployService(params, context);
      case 'delete_service':
        return await this.deleteService(params.name || params.service, params.region);
      case 'list_services':
        return await this.listServices(params.region);

      // Storage
      case 'create_bucket':
        return await this.createBucket(params.name || params.bucket, params.location);
      case 'upload':
        return await this.uploadToBucket(params.bucket, params.file, params.path);
      case 'list_buckets':
        return await this.listBuckets();

      // Pub/Sub
      case 'create_topic':
        return await this.createTopic(params.name || params.topic);
      case 'publish':
        return await this.publishMessage(params.topic, params.message);

      // RexxJS deployment
      case 'deploy_rexx':
        return await this.deployRexxFunction(params.script, params.name);

      // Info
      case 'info':
        return {
          handler: 'GCP',
          version: '1.0.0',
          project: this.project,
          region: this.region,
          activeFunctions: Array.from(this.activeFunctions.keys()),
          activeServices: Array.from(this.activeServices.keys())
        };

      default:
        throw new Error(`Unknown GCP method: ${method}`);
    }
  }
}

// Export for Node.js
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    UnifiedGcpHandler,
    AddressGcpHandler: UnifiedGcpHandler, // Alias for backward compatibility
    // Export as function (not constant) for RexxJS metadata detection
    GCP_ADDRESS_META: function() { return GCP_ADDRESS_META; },
    ADDRESS_GCP_HANDLER,
    // Also export the handler functions
    ADDRESS_GCP_MAIN: function() { return GCP_ADDRESS_META; }
  };
}

// Register as global for RexxJS
const globalScope = (typeof global !== 'undefined') ? global : (typeof window !== 'undefined') ? window : {};
if (typeof globalScope === 'object') {
  globalScope.UnifiedGcpHandler = UnifiedGcpHandler;
  globalScope.AddressGcpHandler = UnifiedGcpHandler; // Alias for backward compatibility

  // Store metadata constant before overwriting with function
  const GCP_META_DATA = GCP_ADDRESS_META;

  globalScope.ADDRESS_GCP_HANDLER = ADDRESS_GCP_HANDLER;

  // Detection function for RexxJS REQUIRE system
  globalScope.ADDRESS_GCP_MAIN = function() {
    return GCP_META_DATA;
  };

  // Export metadata as a function for @rexxjs-meta detection
  globalScope.GCP_ADDRESS_META = function() {
    return GCP_META_DATA;
  };

  // Use shared handler instance for first-class method access

  // First-class method exports
  globalScope.GCP_DEPLOY_SERVICE = async (params) => {
    const handler = await initGcpHandler();
    return await handler.deployService(params);
  };

  globalScope.GCP_DELETE_SERVICE = async (name, region) => {
    const handler = await initGcpHandler();
    return await handler.deleteService(name, region);
  };

  globalScope.GCP_LIST_SERVICES = async (region) => {
    const handler = await initGcpHandler();
    return await handler.listServices(region);
  };

  globalScope.GCP_DEPLOY_FUNCTION = async (params) => {
    const handler = await initGcpHandler();
    return await handler.deployFunction(params);
  };

  globalScope.GCP_LIST_FUNCTIONS = async () => {
    const handler = await initGcpHandler();
    return await handler.listFunctions();
  };

  globalScope.GCP_INFO = async () => {
    const handler = await initGcpHandler();
    return await handler.handle('info');
  };
}
